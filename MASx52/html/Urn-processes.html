<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="author" content="Nic Freeman" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="description" content="MAS352/452/6052 Stochastic Processes and Financial Mathematics, Sheffield University, September 22, 2022." />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<!--[if lt IE 9]>
<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
<title>MASx52 â€” Urn processes</title>
<link rel="stylesheet" type="text/css" href="lwarp-sagebrush.css" />
<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
  subequations: "0",
  section: "",
  loader: {
    load: ['[tex]/tagformat', '[tex]/textmacros'],
  },
  startup: {
    ready() {
      // These would be replaced by import commands if you wanted to make
      // a proper extension.
      const Configuration = MathJax._.input.tex.Configuration.Configuration;
      const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
      const Macro = MathJax._.input.tex.Symbol.Macro;
      const TexError = MathJax._.input.tex.TexError.default;
      const ParseUtil = MathJax._.input.tex.ParseUtil.default;
      const expandable = MathJax._.util.Options.expandable;

        // Insert the replacement string into the TeX string, and check
        // that there haven't been too many maxro substitutions (prevents
        // infinite loops).
        const useArgument = (parser, text) => {
          parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
          parser.i = 0;
          if (++parser.macroCount > parser.configuration.options.maxMacros) {
            throw new TexError('MaxMacroSub1',
            'MathJax maximum macro substitution count exceeded; ' +
            'is there a recursive macro call?');
          }
        }

        // Create the command map for:
        //     \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
        new CommandMap('Lwarp-macros', {
          ifstar: 'IfstarFunction',
          ifnextchar: 'IfnextcharFunction',
          ifblank: 'IfblankFunction',
          ifstrequal: 'IfstrequalFunction',
          gsubstitute: 'GsubstituteFunction',
          seteqnumber: 'SeteqnumberFunction'
        }, {
          // This function implements an ifstar macro.
          IfstarFunction(parser, name) {
             const resultstar = parser.GetArgument(name);
             const resultnostar = parser.GetArgument(name);
             const star = parser.GetStar();                 // true if there is a *
             useArgument(parser, star ? resultstar : resultnostar);
          },

          // This function implements an ifnextchar macro.
          IfnextcharFunction(parser, name) {
            let whichchar = parser.GetArgument(name);
            if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
              // $ syntax highlighting
              whichchar = String.fromCodePoint(parseInt(whichchar));
            }
            const resultnextchar = parser.GetArgument(name);
            const resultnotnextchar = parser.GetArgument(name);
            const gotchar = (parser.GetNext() === whichchar);
            useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
          },

          // This function implements an ifblank macro.
          IfblankFunction(parser, name) {
            const blankarg = parser.GetArgument(name);
            const resultblank = parser.GetArgument(name);
            const resultnotblank = parser.GetArgument(name);
            const isblank = (blankarg.trim() == "");
            useArgument(parser, isblank ? resultblank : resultnotblank);
          },

          // This function implements an ifstrequal macro.
          IfstrequalFunction(parser, name) {
            const strequalfirst = parser.GetArgument(name);
            const strequalsecond = parser.GetArgument(name);
            const resultequal = parser.GetArgument(name);
            const resultnotequal = parser.GetArgument(name);
            const isequal = (strequalfirst == strequalsecond);
            useArgument(parser, isequal ? resultequal : resultnotequal);
          },

          // This function implements a gsub macro.
          GsubstituteFunction(parser, name) {
            const gsubfirst = parser.GetArgument(name);
            const gsubsecond = parser.GetArgument(name);
            const gsubthird = parser.GetArgument(name);
            let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
            useArgument(parser, gsubresult);
          },

          // This function modifies the equation numbers.
          SeteqnumberFunction(parser, name) {
              // Get the macro parameters
              const star = parser.GetStar();                  // true if there is a *
              const optBrackets = parser.GetBrackets(name);   // contents of optional brackets
              const newsubequations = parser.GetArgument(name); // the subequations argument
              const neweqsection = parser.GetArgument(name); // the eq section argument
              const neweqnumber = parser.GetArgument(name);   // the eq number argument
              MathJax.config.subequations=newsubequations ;   // a string with boolean meaning
              MathJax.config.section=neweqsection ;           // a string with numeric meaning
              parser.tags.counter = parser.tags.allCounter = neweqnumber ;
          }

        });

        // Create the Lwarp-macros package
        Configuration.create('Lwarp-macros', {
          handler: {macro: ['Lwarp-macros']}
        });

        MathJax.startup.defaultReady();

        // For forward references:
        MathJax.startup.input[0].preFilters.add(({math}) => {
          if (math.inputData.recompile){
              MathJax.config.subequations = math.inputData.recompile.subequations;
              MathJax.config.section = math.inputData.recompile.section;
          }
        });
        MathJax.startup.input[0].postFilters.add(({math}) => {
          if (math.inputData.recompile){
              math.inputData.recompile.subequations = MathJax.config.subequations;
              math.inputData.recompile.section = MathJax.config.section;
          }
        });

          // For \left, \right with unicode-math:
          const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
          const {Symbol} = MathJax._.input.tex.Symbol;
          const {MapHandler} = MathJax._.input.tex.MapHandler;
          const delimiter = MapHandler.getMap('delimiter');
          delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
          delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
          delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
          delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
          delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
          delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
          delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
          delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
          delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
          delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
          delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
          delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
          delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
          delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
          delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
          delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
          delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
          delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
          delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
          delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
          delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
          delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
          delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
          delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
          delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
          delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
          delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
          delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
          delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
          delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
          delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
          delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
          delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
          delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
          delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
          delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
          delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
          delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
          delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
    }     // ready
  },      // startup

  tex: {
    packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
    tags: "ams",
         tagformat: {
             number: function (n) {
                 if(MathJax.config.subequations==0)
                     return(MathJax.config.section + n);
                 else
                     return(MathJax.config.section + String.fromCharCode(96+n));
             },
         },
  }
}
</script>

<script
    id="MathJax-script"
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>


</head>
<body>



<a id="notes_1-autopage-116"></a>
<nav class="topnavigation"><a href="notes_1.html" class="linkhome" >
Home</a></nav>

<header>

<p>
last updated: September 22, 2022
</p>

</header>



<div class="bodyandsidetoc">
<div class="sidetoccontainer">



<nav class="sidetoc">



<div class="sidetoctitle">

<p>
<span class="sidetocthetitle">Stochastic Processes and Financial Mathematics<br />
(part one)</span>
</p>

<p>
Contents
</p>
</div>



<div class="sidetoccontents">

<p>
<a href="notes_1.html" class="linkhome" >
Home</a>
</p>

</div>

</nav>

</div>



<main class="bodycontainer">



<section class="textbody">

<h1>Stochastic Processes and Financial Mathematics<br />
(part one)</h1>

<!--MathJax customizations:-->



<div class="hidden">

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\DeclareMathOperator {\var }{var}\)

\(\DeclareMathOperator {\cov }{cov}\)

\(\newcommand {\nN }{n \in \mathbb {N}}\)

\(\newcommand {\Br }{{\cal B}(\R )}\)

\(\newcommand {\F }{{\cal F}}\)

\(\newcommand {\ds }{\displaystyle }\)

\(\newcommand {\st }{\stackrel {d}{=}}\)

\(\newcommand {\uc }{\stackrel {uc}{\rightarrow }}\)

\(\newcommand {\la }{\langle }\)

\(\newcommand {\ra }{\rangle }\)

\(\newcommand {\li }{\liminf _{n \rightarrow \infty }}\)

\(\newcommand {\ls }{\limsup _{n \rightarrow \infty }}\)

\(\newcommand {\limn }{\lim _{n \rightarrow \infty }}\)

\(\def \ra {\Rightarrow }\)

\(\def \to {\rightarrow }\)

\(\def \iff {\Leftrightarrow }\)

\(\def \sw {\subseteq }\)

\(\def \wt {\widetilde }\)

\(\def \mc {\mathcal }\)

\(\def \mb {\mathbb }\)

\(\def \sc {\setminus }\)

\(\def \v {\textbf }\)

\(\def \p {\partial }\)

\(\def \E {\mb {E}}\)

\(\def \P {\mb {P}}\)

\(\def \R {\mb {R}}\)

\(\def \C {\mb {C}}\)

\(\def \N {\mb {N}}\)

\(\def \Q {\mb {Q}}\)

\(\def \Z {\mb {Z}}\)

\(\def \B {\mb {B}}\)

\(\def \~{\sim }\)

\(\def \-{\,;\,}\)

\(\def \|{\,|\,}\)

\(\def \qed {$\blacksquare $}\)

\(\def \1{\unicode {x1D7D9}}\)

\(\def \cadlag {c\&grave;{a}dl\&grave;{a}g}\)

\(\def \p {\partial }\)

\(\def \l {\left }\)

\(\def \r {\right }\)

\(\def \F {\mc {F}}\)

\(\def \G {\mc {G}}\)

\(\def \H {\mc {H}}\)

\(\def \Om {\Omega }\)

\(\def \om {\omega }\)

</div>

<p>
<!--
......     section Urn processes ......
-->
<h4 id="autosec-117"><span class="sectionnumber">4.2&#x2003;</span>Urn processes</h4>
<a id="notes_1-autopage-117"></a>
<a id="notes_1-autofile-17"></a> <a id="sec:urn"></a>

<p>
Urn processes are â€˜balls in bagsâ€™ processes. In the simplest kind of urn process, which we look at in this section, we have just a single urn (i.e.&nbsp;bag) that contains balls of two different colours.
</p>

<p>
At time \(0\), an urn contains \(1\) black ball and \(1\) red ball. Then, for each \(n=1,2,\ldots ,\) we generate the state of the urn at time \(n\) by doing the following:
</p>
<ul style="list-style-type:none">


<li>
<p>
1. Draw a ball from the urn, look at its colour, and return this ball to the urn.
</p>


</li>
<li>


<p>
2. Add a new ball of the same colour as the drawn ball.
</p>
</li>
</ul>

<p>
So, at time \(n\) (which means: after the \(n^{th}\) iteration of the above steps is completed) there are \(n+2\) balls in the urn. This process is known as the <i>Po&#x0301;lya</i> urn.
</p>

<p>
Let \(B_n\) be the number of red balls in the urn at time \(n\), and note that \(B_0=1\). Set \((\mc {F}_n)\) to be the filtration generated by \((B_n)\).
</p>

<p>
Our first step is to note that \(B_n\) itself is <i>not</i> a martingale. The reason is that over time we will put more and more red balls into the urn, so the number of red balls drifts upwards over time. Formally,
we can note that
</p>
<span class="hidden"> \(\seteqnumber{0}{4.}{3}\)</span>



<!--



                                                                    E[Bn+1 | Fn ] = E[Bn+1 1{(n+1)th draw is red} | Fn ] + E[Bn+1 1{(n+1)th draw is black} | Fn ]

                                                                                    = E[(Bn + 1)1{(n+1)th draw is red} | Fn ] + E[Bn 1{(n+1)th draw is black} | Fn ]

                                                                                    = (Bn + 1)E[1{(n+1)th draw is red} | Fn ] + Bn E[1{(n+1)th draw is black} | Fn ]
                                                                                                Bn            Bn
                                                                                                                           
                                                                                    = (Bn + 1)      + Bn 1 âˆ’
                                                                                               n+2           n+2
                                                                                      Bn (n + 3)
                                                                                    = (4.4)      > Bn .                                                                       --><a id="eq:urn_Bn_submart"></a><!--
                                                                                        n+2



-->



<p>


\begin{align}
\E [B_{n+1}\|\mc {F}_n] &amp;=\E [B_{n+1}\1_{\{(n+1)^{th}\text { draw is red}\}}\|\mc {F}_n] +\E [B_{n+1}\1_{\{(n+1)^{th}\text { draw is black}\}}\|\mc {F}_n]\notag \\ &amp;=\E
[(B_n+1)\1_{\{(n+1)^{th}\text { draw is red}\}}\|\mc {F}_n] +\E [B_n\1_{\{(n+1)^{th}\text { draw is black}\}}\|\mc {F}_n]\notag \\ &amp;=(B_n+1)\E [\1_{\{(n+1)^{th}\text { draw
is red}\}}\|\mc {F}_n] +B_n\E [\1_{\{(n+1)^{th}\text { draw is black}\}}\|\mc {F}_n]\notag \\ &amp;=(B_n+1)\frac {B_n}{n+2}+B_n\l (1-\frac {B_n}{n+2}\r )\notag \\ &amp;=\frac
{B_n(n+3)}{n+2}&gt;B_n.\label {eq:urn_Bn_submart}
\end{align}
We do have \(B_n\in m\mc {F}_n\) and since \(1\leq B_n\leq n+2\) we also have \(B_n\in L^1\), so \(B_n\) is a submartingale, but due to <span class="textup">(<a
href="Urn-processes.html#eq:urn_Bn_submart">4.4</a>)</span> \(B_n\) is not a martingale.
</p>

<p>
However, a closely related quantity is a martingale. Let
</p>

<p>
\[M_n=\frac {B_n}{n+2}.\]
</p>

<p>
Then \(M_n\) is the proportion of balls in the urn that are red, at time \(n\). Note that \(M_n\in [0,1]\). We can think of the extra factor \(n+2\), which increases over time, as an attempt to cancel out the
upwards drift of \(B_n\). We now have:
</p>
<span class="hidden"> \(\seteqnumber{0}{4.}{4}\)</span>



<!--



                                                                 E[Mn+1 | Fn ] = E Mn+1 1{(n+1)th draw is red} Fn + E Mn+1 1{(n+1)th draw is black} Fn
                                                                                      h                                 i       h                                 i


                                                                                       Bn + 1                                Bn
                                                                                                                                                                    
                                                                                =E            1      th             Fn + E       1      th               Fn
                                                                                        n + 3 {(n+1) draw is red}           n + 3 {(n+1) draw is black}
                                                                                    Bn + 1 h                              Bn
                                                                                           E 1{(n+1)th draw is red} Fn +      E 1{(n+1)th draw is black} Fn
                                                                                                                      i        h                            i
                                                                                =
                                                                                     n+3                                 n+3
                                                                                    Bn + 1 Bn        Bn            Bn
                                                                                                                      
                                                                                =                +          1âˆ’
                                                                                     n+3 n+2 n+3                  n+2
                                                                                         2
                                                                                       Bn + Bn       (n + 2)Bn âˆ’ Bn2
                                                                                =                  +
                                                                                    (n + 2)(n + 3)    (n + 2)(n + 3)
                                                                                      (n + 3)Bn
                                                                                =
                                                                                    (n + 2)(n + 3)
                                                                                     Bn
                                                                                =
                                                                                    n+2
                                                                                = Mn .



-->



<p>


\begin{align*}
\E [M_{n+1}\|\mc {F}_n] &amp;=\E \l [M_{n+1}\1_{\{(n+1)^{th}\text { draw is red}\}}\,\Big |\,\mc {F}_n\r ] +\E \l [M_{n+1}\1_{\{(n+1)^{th}\text { draw is black}\}}\,\Big |\,\mc
{F}_n\r ]\\ &amp;=\E \l [\frac {B_n+1}{n+3}\,\1_{\{(n+1)^{th}\text { draw is red}\}}\,\Big |\,\mc {F}_n\r ] +\E \l [\frac {B_n}{n+3}\,\1_{\{(n+1)^{th}\text { draw is
black}\}}\,\Big |\,\mc {F}_n\r ]\\ &amp;=\frac {B_n+1}{n+3}\E \l [\1_{\{(n+1)^{th}\text { draw is red}\}}\,\Big |\,\mc {F}_n\r ] +\frac {B_n}{n+3}\E \l [\,\1_{\{(n+1)^{th}\text {
draw is black}\}}\,\Big |\,\mc {F}_n\r ]\\ &amp;=\frac {B_n+1}{n+3}\frac {B_n}{n+2}+\frac {B_n}{n+3}\l (1-\frac {B_n}{n+2}\r )\\ &amp;=\frac {B_n^2+B_n}{(n+2)(n+3)}+\frac
{(n+2)B_n-B_n^2}{(n+2)(n+3)}\\ &amp;=\frac {(n+3)B_n}{(n+2)(n+3)}\\ &amp;=\frac {B_n}{n+2}\\ &amp;=M_n.
\end{align*}
We have \(M_n\in m\mc {F}_n\) and since \(M_n\in [0,1]\) we have that \(M_n\in L^1\). Hence \((M_n)\) is a martingale.
</p>

<p>
We can think of \(M_n=\frac {B_n}{n+2}\) as a compensation mechanism; \(B_n\) tends to increase, and we compensate for this increase by dividing by \(n+2\).
</p>
<div class="theorembodyremark">

<ul style="list-style-type:none">



<a id="autoid-82"></a>
<li>
<p>
<span class="theoremheaderplain">Remark 4.2.1</span> <a id="autoid-83" ></a >The calculation of \(\E [M_{n+1}\|\mc {F}_n]\) is written out in full as a second example of the method. In fact, we
could simply have divided the equality in <span class="textup">(<a href="Urn-processes.html#eq:urn_Bn_submart">4.4</a>)</span> by \(n+3\), and obtained \(\E [M_{n+1}\|\mc {F}_n]=M_n\).
</p>


</li>

</ul>

</div>
<!--
......   subsection On fairness ......
-->
<h5 id="autosec-119">On fairness</h5>
<a id="notes_1-autopage-119"></a>



<p>
It is clear that the symmetric random walk is fair; at all times it is equally likely to move up as down. The asymmetric random walk is not fair, due to its drift <span class="textup">(<a
href="Stochastic-processes.html#eq:rw_drift">4.2</a>)</span>, but once we compensate for drift in <span class="textup">(<a
href="Stochastic-processes.html#eq:drift_compensate">4.3</a>)</span> we do still obtain a martingale.
</p>

<p>
Then urn process requires more careful thought. For example, we might wonder:
</p>
<blockquote>

<p>
<i>Suppose that the first draw is red. Then, at time \(n=1\) we have two red balls and one black ball. So, the chance of drawing a red ball is now \(\frac {2}{3}\). How is this fair?!</i>
</p>
</blockquote>

<p>
To answer this question, let us make a number of points. Firstly, let us remind ourselves that the quantity which is a martingale is \(M_n\), the <i>proportion</i> of red balls in the urn.
</p>

<p>
Secondly, suppose that the first draw is indeed red. So, at \(n=1\) we have \(2\) red and \(1\) black, giving a proportion of \(\frac {2}{3}\) red and \(\frac 13\) black. The expected fraction of red balls after
the next (i.e.&nbsp;second) draw is
</p>

<p>
\[\frac 23\cdot \frac {(2+1)}{4}+\frac 13\cdot \frac 24=\frac {6+2}{12}=\frac 23\]
</p>

<p>
which is of course equal to the proportion of red balls that we had at \(n=1\).
</p>

<p>
Lastly, note that it is equally likely that, on the first go, youâ€™d pick out a black. So, starting from \(n=0\) and looking forwards, both colors have equally good chances of increasing their own numbers. In fact, if we
were to pretend, right from the start, that black was red, and red was black, we would see the same urn process. This type of fairness is known as symmetry. Weâ€™ve seen that \(B_n\) tends to increase (because we
keep adding more balls), and we can think of \(M_n\) as a way of discovering the fairness â€˜hidingâ€™ inside of \(B_n\).
</p>

<p>
To sum up: in life there are different ways to think of â€˜fairnessâ€™ â€“ and what we need to do here is get a sense for precisely what kind of fairness martingales characterize. The fact that \(M_n\) is a martingale does not
prevent us from (sometimes) ending up with many more red balls than black, or vice versa. It just means that, when viewed in terms of \(M_n\), there is no bias towards red of black inherent in the rules of the game.
</p>

</section>

</main>

</div>

<footer>

<p>
Copyright Nic Freeman, Sheffield University, last updated September 22, 2022
</p>

</footer>



<nav class="botnavigation"><a href="notes_1.html" class="linkhome" >
Home</a></nav>

</body>
</html>
