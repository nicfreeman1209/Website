<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="author" content="Nic Freeman" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="description" content="MAS352/61023 Stochastic Processes and Financial Mathematics, Sheffield University, April 22, 2025." />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>MAS352/61023 â€” Simple random walks </title>
<link rel="stylesheet" type="text/css" href="sans-serif-lwarp-sagebrush.css" />
<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
  subequations: "0",
  section: "",
  loader: {
    load: ['[tex]/tagformat', '[tex]/textmacros'],
  },
  startup: {
    ready() {
      // These would be replaced by import commands if you wanted to make
      // a proper extension.
      const Configuration = MathJax._.input.tex.Configuration.Configuration;
      const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
      const Macro = MathJax._.input.tex.Symbol.Macro;
      const TexError = MathJax._.input.tex.TexError.default;
      const ParseUtil = MathJax._.input.tex.ParseUtil.default;
      const expandable = MathJax._.util.Options.expandable;

        // Insert the replacement string into the TeX string, and check
        // that there haven't been too many maxro substitutions (prevents
        // infinite loops).
        const useArgument = (parser, text) => {
          parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
          parser.i = 0;
          if (++parser.macroCount > parser.configuration.options.maxMacros) {
            throw new TexError('MaxMacroSub1',
            'MathJax maximum macro substitution count exceeded; ' +
            'is there a recursive macro call?');
          }
        }

        // Create the command map for:
        //     \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
        new CommandMap('Lwarp-macros', {
          ifstar: 'IfstarFunction',
          ifnextchar: 'IfnextcharFunction',
          ifblank: 'IfblankFunction',
          ifstrequal: 'IfstrequalFunction',
          gsubstitute: 'GsubstituteFunction',
          seteqnumber: 'SeteqnumberFunction'
        }, {
          // This function implements an ifstar macro.
          IfstarFunction(parser, name) {
             const resultstar = parser.GetArgument(name);
             const resultnostar = parser.GetArgument(name);
             const star = parser.GetStar();                 // true if there is a *
             useArgument(parser, star ? resultstar : resultnostar);
          },

          // This function implements an ifnextchar macro.
          IfnextcharFunction(parser, name) {
            let whichchar = parser.GetArgument(name);
            if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
              // $ syntax highlighting
              whichchar = String.fromCodePoint(parseInt(whichchar));
            }
            const resultnextchar = parser.GetArgument(name);
            const resultnotnextchar = parser.GetArgument(name);
            const gotchar = (parser.GetNext() === whichchar);
            useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
          },

          // This function implements an ifblank macro.
          IfblankFunction(parser, name) {
            const blankarg = parser.GetArgument(name);
            const resultblank = parser.GetArgument(name);
            const resultnotblank = parser.GetArgument(name);
            const isblank = (blankarg.trim() == "");
            useArgument(parser, isblank ? resultblank : resultnotblank);
          },

          // This function implements an ifstrequal macro.
          IfstrequalFunction(parser, name) {
            const strequalfirst = parser.GetArgument(name);
            const strequalsecond = parser.GetArgument(name);
            const resultequal = parser.GetArgument(name);
            const resultnotequal = parser.GetArgument(name);
            const isequal = (strequalfirst == strequalsecond);
            useArgument(parser, isequal ? resultequal : resultnotequal);
          },

          // This function implements a gsub macro.
          GsubstituteFunction(parser, name) {
            const gsubfirst = parser.GetArgument(name);
            const gsubsecond = parser.GetArgument(name);
            const gsubthird = parser.GetArgument(name);
            let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
            useArgument(parser, gsubresult);
          },

          // This function modifies the equation numbers.
          SeteqnumberFunction(parser, name) {
              // Get the macro parameters
              const star = parser.GetStar();                  // true if there is a *
              const optBrackets = parser.GetBrackets(name);   // contents of optional brackets
              const newsubequations = parser.GetArgument(name); // the subequations argument
              const neweqsection = parser.GetArgument(name); // the eq section argument
              const neweqnumber = parser.GetArgument(name);   // the eq number argument
              MathJax.config.subequations=newsubequations ;   // a string with boolean meaning
              MathJax.config.section=neweqsection ;           // a string with numeric meaning
              parser.tags.counter = parser.tags.allCounter = neweqnumber ;
          }

        });

        // Create the Lwarp-macros package
        Configuration.create('Lwarp-macros', {
          handler: {macro: ['Lwarp-macros']}
        });

        MathJax.startup.defaultReady();

        // For forward references:
        MathJax.startup.input[0].preFilters.add(({math}) => {
          if (math.inputData.recompile){
              MathJax.config.subequations = math.inputData.recompile.subequations;
              MathJax.config.section = math.inputData.recompile.section;
          }
        });
        MathJax.startup.input[0].postFilters.add(({math}) => {
          if (math.inputData.recompile){
              math.inputData.recompile.subequations = MathJax.config.subequations;
              math.inputData.recompile.section = MathJax.config.section;
          }
        });

          // For \left, \right with unicode-math:
          const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
          const {Symbol} = MathJax._.input.tex.Symbol;
          const {MapHandler} = MathJax._.input.tex.MapHandler;
          const delimiter = MapHandler.getMap('delimiter');
          delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
          delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
          delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
          delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
          delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
          delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
          delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
          delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
          delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
          delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
          delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
          delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
          delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
          delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
          delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
          delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
          delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
          delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
          delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
          delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
          delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
          delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
          delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
          delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
          delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
          delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
          delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
          delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
          delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
          delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
          delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
          delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
          delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
          delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
          delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
          delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
          delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
          delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
          delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
    }     // ready
  },      // startup

  tex: {
    packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
    tags: "ams",
         tagformat: {
             number: function (n) {
                 if(MathJax.config.subequations==0)
                     return(MathJax.config.section + n);
                 else
                     return(MathJax.config.section + String.fromCharCode(96+n));
             },
         },
  }
}
</script>

<script
    id="MathJax-script"
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-J4222H8D03"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-J4222H8D03');
</script>
<!-- Google tag (gtag.js) -->


</head>
<body>



<a id="notes_1-autopage-267"></a>
<nav class="topnavigation"><a href="notes_1.html" class="linkhome" >
Home</a></nav>

<header>

<p>
last updated: April 22, 2025
</p>

</header>



<div class="bodyandsidetoc">
<div class="sidetoccontainer">



<nav class="sidetoc">



<div class="sidetoctitle">

<p>
<span class="sidetocthetitle">Stochastic Processes and Financial Mathematics<br />
(part one)</span>
</p>

<p>
Contents
</p>
</div>



<div class="sidetoccontents">

<p>
<a href="notes_1.html" class="linkhome" >
Home</a>
</p>

</div>

</nav>

</div>



<main class="bodycontainer">



<section class="textbody">

<h1>Stochastic Processes and Financial Mathematics<br />
(part one)</h1>

<!--MathJax customizations:-->
<div data-nosnippet
      style="display:none"
>

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\DeclareMathOperator {\var }{var}\)

\(\DeclareMathOperator {\cov }{cov}\)

\(\def \ra {\Rightarrow }\)

\(\def \to {\rightarrow }\)

\(\def \iff {\Leftrightarrow }\)

\(\def \sw {\subseteq }\)

\(\def \wt {\widetilde }\)

\(\def \mc {\mathcal }\)

\(\def \mb {\mathbb }\)

\(\def \sc {\setminus }\)

\(\def \v {\textbf }\)

\(\def \p {\partial }\)

\(\def \E {\mb {E}}\)

\(\def \P {\mb {P}}\)

\(\def \R {\mb {R}}\)

\(\def \C {\mb {C}}\)

\(\def \N {\mb {N}}\)

\(\def \Q {\mb {Q}}\)

\(\def \Z {\mb {Z}}\)

\(\def \B {\mb {B}}\)

\(\def \~{\sim }\)

\(\def \-{\,;\,}\)

\(\def \|{\,|\,}\)

\(\def \qed {$\blacksquare $}\)

\(\def \1{\unicode {x1D7D9}}\)

\(\def \cadlag {c\&grave;{a}dl\&grave;{a}g}\)

\(\def \p {\partial }\)

\(\def \l {\left }\)

\(\def \r {\right }\)

\(\def \F {\mc {F}}\)

\(\def \G {\mc {G}}\)

\(\def \H {\mc {H}}\)

\(\def \Om {\Omega }\)

\(\def \om {\omega }\)

</div>

<!--
......     chapter Simple random walks     ......
-->
<h3 id="autosec-268">Chapter&nbsp;<span class="sectionnumber">9&#x2003;</span>Simple random walks \(\msconly \)</h3>
<a id="notes_1-autopage-268"></a>
<a id="notes_1-autofile-42"></a>

<a id="c:rws"></a>

<p>
In Section <a href="notes_1.html#??">??</a> we studied the long-term behaviour of the Polya urn and the Galton-Watson process, by taking a limit as the time parameter tended to infinity of a suitably chosen
martingale. The following result shows that these techniques do not (or at least, not directly) explain how random walks might behave. In this chapter we will focus on the case of <i>simple</i> random walks,
which means that they move precisely one unit of space, upwards or downwards, in each step of time.
</p>
<div class="theorembodylemma">

<ul class="list" style="list-style-type:none">



<a id="autoid-198"></a>
<li>
<p>
<span class="listmarker"> <span class="theoremheaderplain">Lemma 9.0.1</span></span> <a id="autoid-199" ></a >Let \(S_n=\sum _{i=1}^n X_i\) where \(\P [X_i=1]=p\) and \(\P
[X_i=-1]=1-p\), and the \((X_i)\) are independent of each other. Then \((S_n)\) does not converge almost surely to a real valued random variable and \((S_n)\) is not uniformly bounded in \(L^1\).
</p>


</li>

</ul>

</div>

<p>
<span class="textsc">Proof:</span><span style="width:5.38533pt; display:inline-block"><!----></span> The process \((S_n)\) is integer valued. From Lemma <a
href="notes_1.html#??">??</a> we have that, if \((S_n)\) were to converge almost surely, it would have to eventually become constant. By definition we have \(|S_{n+1}-S_n|=1\), so this cannot happen,
hence \((S_n)\) does not convergence almost surely.
</p>

<p>
In the case \(p=\frac 12\) we have that \((S_n)\) is a martingale. If \((S_n)\) was also uniformly bounded in \(L^1\) then the martingale convergence theorem would imply almost sure convergence, so from
what we have already proved \((S_n)\) is not uniformly bounded in \(L^1\). For the case \(p\neq \frac 12\), we have shown in <span class="textup">(<a href="notes_1.html#??">??</a>)</span> that
\(M_n=S_n-n(p-q)\) is a martingale, hence \(\E [S_n]=n(p-q)\) and therefore \(|\E [S_n]|\to \infty \). By the absolute values property of expectations \(|E[S_n]|\leq \E [|S_n|]\), hence \(\E
[|S_n|]\to \infty \), so \((S_n)\) is not uniformly bounded in \(L^1\). &#x2003;&#x2003;&#x220E;
</p>

<p>
In fact, as we mentioned briefly (and without proof) in Section <a href="notes_1.html#??">??</a>, random walks exhibit a mixture of oscillatory behaviour and divergence to \(\pm \infty \). We will study
this behaviour here, as well as considering some other closely related properties of random walks. The techniques we will use are primarily those developed in Chapter <a href="notes_1.html#??">??</a>.
</p>

<p>
This chapter will make use of some of the exercises from earlier chapters, including within the proofs. Make sure that you study these too, when they appear, if you have not done so already. As a reminder: the
solutions to all of the end-of-chapter exercises can be found within the online version of the lecture notes.
</p>
<!--
......   section Exit probabilities       ......
-->
<h4 id="autosec-270"><span class="sectionnumber">9.1&#x2003;</span>Exit probabilities \(\msconly \)</h4>
<a id="notes_1-autopage-270"></a>



<a id="s:rw_exit"></a>

<p>
We recall the asymmetric random walk from Section <a href="notes_1.html#??">??</a>. Let \((X_i)_{i=1}^\infty \) be a sequence of i.i.d.&nbsp;random variables. Let \(p+q=1\) with \(p,q\in (0,1)\),
\(p\neq q\) and suppose that
</p>

<p>
\[\P [X_i=1]=p,\hspace {1pc}\P [X_i=-1]=q.\]
</p>

<p>
The asymmetric random walk is the stochastic process
</p>

<p>
\[S_n=\sum \limits _{i=1}^n X_i.\]
</p>

<p>
Set \(\mc {F}_n=\sigma (X_1,\ldots ,X_n)\) and note that \((\mc {F}_n)\) is the natural filtration of \(S_n\). Recall that we showed in Section <a href="notes_1.html#??">??</a> that the stochastic
process \(S_n-n(p-q)\) was a martingale. In Exercise <a href="notes_1.html#??">??</a> we found another martingale associated to \((S_n)\), in particular we showed that
</p>

<p>
\[M_n = (q/p)^{S_n}\]
</p>

<p>
is a martingale.
</p>

<p>
Our plan is to use the optional stopping theorem, applied to the martingale \((M_n)\), to obtain information about the hitting times of the asymmetric random walk. Let \(T_a=\inf \{n:   S_n=a\}\) and \(T=T_a
\wedge T_b\) for integer \(a&lt;0&lt;b\). We aim to calculate \(\P [T=T_a]\) and \(\P [T=T_b]\). We can show that \(T_a\) is a stopping time by noting that
</p>

<p>
\[\{T_a\leq n\}=\bigcup _{i=0}^n \{S_i\leq a\}.\]
</p>

<p>
Similarly, \(T_b\) is a stopping time and it follows from Lemma <a href="notes_1.html#??">??</a> that \(T\) is also a stopping time.
</p>

<p>
We now look to apply the optional stopping theorem, using the (b) conditions. For this, weâ€™ll need the following lemma.
</p>
<div class="theorembodylemma">

<ul class="list" style="list-style-type:none">



<a id="autoid-200"></a>
<li>
<p>
<span class="listmarker"> <span class="theoremheaderplain">Lemma 9.1.1</span></span> <a id="autoid-201" ></a ><a id="l:E_T_biased"></a> It holds that \(\E [T]&lt;\infty \).
</p>


</li>

</ul>

</div>

<p>
<span class="textsc">Proof:</span><span style="width:5.38533pt; display:inline-block"><!----></span> Let \(m=b-a\). Divide up the random variables \((X_n)\) into sets \(A_1,A_2,\ldots \) as
follows:
</p>

<span class="hidden"> \(\seteqnumber{0}{9.}{0}\)</span>

<!--


                                                                          A1                          A2                            A3                      ...
                                                                z         }|          { z             }|            { z             }|             { z      }|    {
                                                                X1 , X2 , X3 , . . . , Xm , Xm+1 , Xm+2 , . . . , X2m , X2m+1 , X2m+2 , . . . , X3m , X3m+1 , . . . .                                    (9.1)

-->

<p>


\begin{equation}
\overbrace {X_1,X_2,X_3,\ldots ,X_m}^{A_1},\,\overbrace {X_{m+1},X_{m+2},\ldots ,X_{2m}}^{A_2},\,\overbrace {X_{2m+1},X_{2m+2},\ldots ,X_{3m}}^{A_3},\,\overbrace {X_{3m+1},\ldots
}^{\ldots }.
\end{equation}


</p>

<p>
So as each \(A_k\) contains precisely \(m\) of the \(X_i\)s.
</p>

<p>
Let \(E_k=\{\text {for all }X\in A_k,\,X=1\}\) be the event that all random variables in \(A_k\) are equal to one. Note that if the event \(E_k\) occurs then our random walk moves up by \(m\) steps, during
time \((k-1)m,\ldots ,km\).
</p>

<p>
If \(T\) has not happened before time \((k-1)m\) then \(a&lt;S_{(k-1)m}&lt;b\). Then, if the event \(E_k\) then occurs, we will have \(S_{km}\geq a\) and hence \(T\leq km\). This is best illustrated with a
picture:
</p>
<div class="center">

<p>


<a href="step_up.jpg" target="_blank" ><img
      src="step_up.jpg"
      style="
      width:217pt;
      "
      class="inlineimage"
      alt="(A diagram of the event \(E_k\))"
></a>
</p>
</div>

<p>
We can think of the sequence of events \(E_1,E_2,\ldots \) as one chance after another that our random walker has to exit \([a,b]\).
</p>

<p>
By independence, \(\P [E_k]=p^m\). Hence, the random variable \(K=\inf \{k\in \N \-E_k\text { occurs}\}\) is a geometric random variable with success parameter \(p^m\). This means that
\(K&lt;\infty \) almost surely and that \(\E [K]=p^{-m}&lt;\infty \). By definition of \(K\), the event \(E_K\) occurs so \(T\leq Km\) and by monotonicity of \(\E \) we have \(\E [T]\leq m\E
[K]&lt;\infty \). &#x2003;&#x2003;&#x220E;
</p>

<p>
From above, we have that \(M\) is a martingale. Hence by Lemma <a href="notes_1.html#??">??</a>, \(M^T\) is also a martingale. By definition of \(T\),
</p>
<span class="hidden"> \(\seteqnumber{0}{9.}{1}\)</span>



<!--



                                                                                        if \(q&gt;p\) then (q/p)a â‰¤ MnT â‰¤ (q/p)b

                                                                                        if \(p&gt;q\) then (q/p)a â‰¥ MnT â‰¥ (q/p)b



-->



<p>


\begin{align*}
\text {if $q&gt;p$ then }&amp;(q/p)^a\leq M^T_n\leq (q/p)^b \\ \text {if $p&gt;q$ then }&amp;(q/p)^a\geq M^T_n\geq (q/p)^b
\end{align*}
for all \(n\), hence \(M^T\) is a bounded martingale. Lemma <a href="notes_1.html#??">??</a> implies that \(\P [T&lt;\infty ]=1\), so we have that condition (b) of the optional stopping theorem holds for
the martingale \(M^T\) and the stopping time \(T\). Therefore,
</p>

<p>
\[\E [M^T_T]=\E [M^T_0]\]
</p>

<p>
but \(M^T_T=M_{T\wedge T}=M_T\) and \(M^T_0=M_{0\wedge T}=M_0=1\). So we have
</p>

<p>
\[\E [M_T]=1.\]
</p>

<p>
Our next aim is to calculate the probabilities \(\P [T=T_a]\) and \(\P [T=T_b]\). That is, we want to know which of the two boundaries \(a\) and \(b\) we actually hit at time \(T\) (for example,
\(\{T=T_a\}=\{S_T=a\}\) is the event that we hit \(a\) at time \(T\)).
</p>

<p>
Since \(\P [T&lt;\infty ]=1\), we must hit one or other boundary, so we have that
</p>

<span class="hidden"> \(\seteqnumber{0}{9.}{1}\)</span>

<!--



                                            P[T = Ta ] + P[T = Tb ] = 1.                                                   (9.2)                                   --><a id="eq:asym_rw_stopped_lin_1"></a><!--

-->

<p>


\begin{equation}
\label {eq:asym_rw_stopped_lin_1} \P [T=T_a]+\P [T=T_b]=1.
\end{equation}


</p>

<p>
By partitioning the expectation \(\E [M_T]\) on whether \(\{T=T_a\}\), we have
</p>
<span class="hidden"> \(\seteqnumber{0}{9.}{2}\)</span>



<!--



                                                                                     1 = E[MT ]                                                                                                                     (9.3)

                                                                                      = E[MT 1{T = Ta }] + E[MT 1{T = Tb }]
                                                                                            a                     "                        #
                                                                                                                          b
                                                                                             q                             q
                                                                                                               
                                                                                      =E           1{T = Ta } + E                  1{T = Tb }
                                                                                             p                             p
                                                                                                      a                   b
                                                                                                      q                        q
                                                                                      = P[T = Ta ]              (9.4)
                                                                                                            + P[T = Tb ]            .                              --><a id="eq:asym_rw_stopped_lin_2"></a><!--
                                                                                                      p                        p



-->



<p>


\begin{align}
1&amp;=\E [M_T]\\ &amp;= \E [M_T\1\{T=T_a\}]+\E [M_T\1\{T=T_b\}] \notag \\ &amp;= \E \l [\l (\frac {q}{p}\r )^a\1\{T=T_a\}\r ]+\E \l [\l (\frac {q}{p}\r )^b\1\{T=T_b\}\r ] \notag
\\ &amp;= \P [T=T_a] \l (\frac {q}{p}\r )^a + \P [T=T_b] \l (\frac {q}{p}\r )^b.                     \label {eq:asym_rw_stopped_lin_2}
\end{align}
Solving the linear equations <span class="textup">(<a href="notes_1.html#??">??</a>)</span> and <span class="textup">(<a href="notes_1.html#??">??</a>)</span>, recalling that \(p\neq q\),
gives that
</p>

<span class="hidden"> \(\seteqnumber{0}{9.}{4}\)</span>

<!--


                                                           (q/p)b âˆ’ 1
                                          P[T = Ta ] =                   .                                           (9.5)                                              --><a id="eq:asym_rw_stopped_1"></a><!--
                                                         (q/p)b âˆ’ (q/p)a
-->

<p>


\begin{equation}
\label {eq:asym_rw_stopped_1} \P [T=T_a]=\frac {(q/p)^b-1}{(q/p)^b-(q/p)^a}.
\end{equation}


</p>

<p>
and therefore also
</p>

<span class="hidden"> \(\seteqnumber{0}{9.}{5}\)</span>

<!--


                                                                   1 âˆ’ (q/p)a
                                 P[Tb = T ] = 1 âˆ’ P[T = Ta ] =                   .                                   (9.6)                                              --><a id="eq:asym_rw_stopped_2"></a><!--
                                                                 (q/p)b âˆ’ (q/p)a
-->

<p>


\begin{equation}
\label {eq:asym_rw_stopped_2} \P [T_b=T]=1-\P [T=T_a]=\frac {1-(q/p)^a}{(q/p)^b-(q/p)^a}.
\end{equation}


</p>

<p>
Note that this formula does not make sense if \(p=q=\frac 12\). In that case our two linear equations above are in fact the same equation, so we cannot solve them to find \(\P [T=T_a]\) and \(\P [T=T_b]\).
However, all is not lost: the case of the symmetric random walk can be handled in similar style to above, but we need a different martingale in place of \((M_n)\). This is left for you to do, with some hints along the
way, in Exercise <a href="notes_1.html#??">??</a>
</p>

</section>

</main>

</div>

<footer>

<p>
Copyright Nic Freeman, Sheffield University, last updated April 22, 2025
</p>

</footer>



<nav class="botnavigation"><a href="notes_1.html" class="linkhome" >
Home</a></nav>

</body>
</html>
