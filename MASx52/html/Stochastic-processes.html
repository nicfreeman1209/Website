<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="author" content="Nic Freeman" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="description" content="MAS352/452/6052 Stochastic Processes and Financial Mathematics, Sheffield University, September 22, 2022." />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<!--[if lt IE 9]>
<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
<title>MASx52 — Stochastic processes</title>
<link rel="stylesheet" type="text/css" href="lwarp-sagebrush.css" />
<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
  subequations: "0",
  section: "",
  loader: {
    load: ['[tex]/tagformat', '[tex]/textmacros'],
  },
  startup: {
    ready() {
      // These would be replaced by import commands if you wanted to make
      // a proper extension.
      const Configuration = MathJax._.input.tex.Configuration.Configuration;
      const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
      const Macro = MathJax._.input.tex.Symbol.Macro;
      const TexError = MathJax._.input.tex.TexError.default;
      const ParseUtil = MathJax._.input.tex.ParseUtil.default;
      const expandable = MathJax._.util.Options.expandable;

        // Insert the replacement string into the TeX string, and check
        // that there haven't been too many maxro substitutions (prevents
        // infinite loops).
        const useArgument = (parser, text) => {
          parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
          parser.i = 0;
          if (++parser.macroCount > parser.configuration.options.maxMacros) {
            throw new TexError('MaxMacroSub1',
            'MathJax maximum macro substitution count exceeded; ' +
            'is there a recursive macro call?');
          }
        }

        // Create the command map for:
        //     \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
        new CommandMap('Lwarp-macros', {
          ifstar: 'IfstarFunction',
          ifnextchar: 'IfnextcharFunction',
          ifblank: 'IfblankFunction',
          ifstrequal: 'IfstrequalFunction',
          gsubstitute: 'GsubstituteFunction',
          seteqnumber: 'SeteqnumberFunction'
        }, {
          // This function implements an ifstar macro.
          IfstarFunction(parser, name) {
             const resultstar = parser.GetArgument(name);
             const resultnostar = parser.GetArgument(name);
             const star = parser.GetStar();                 // true if there is a *
             useArgument(parser, star ? resultstar : resultnostar);
          },

          // This function implements an ifnextchar macro.
          IfnextcharFunction(parser, name) {
            let whichchar = parser.GetArgument(name);
            if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
              // $ syntax highlighting
              whichchar = String.fromCodePoint(parseInt(whichchar));
            }
            const resultnextchar = parser.GetArgument(name);
            const resultnotnextchar = parser.GetArgument(name);
            const gotchar = (parser.GetNext() === whichchar);
            useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
          },

          // This function implements an ifblank macro.
          IfblankFunction(parser, name) {
            const blankarg = parser.GetArgument(name);
            const resultblank = parser.GetArgument(name);
            const resultnotblank = parser.GetArgument(name);
            const isblank = (blankarg.trim() == "");
            useArgument(parser, isblank ? resultblank : resultnotblank);
          },

          // This function implements an ifstrequal macro.
          IfstrequalFunction(parser, name) {
            const strequalfirst = parser.GetArgument(name);
            const strequalsecond = parser.GetArgument(name);
            const resultequal = parser.GetArgument(name);
            const resultnotequal = parser.GetArgument(name);
            const isequal = (strequalfirst == strequalsecond);
            useArgument(parser, isequal ? resultequal : resultnotequal);
          },

          // This function implements a gsub macro.
          GsubstituteFunction(parser, name) {
            const gsubfirst = parser.GetArgument(name);
            const gsubsecond = parser.GetArgument(name);
            const gsubthird = parser.GetArgument(name);
            let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
            useArgument(parser, gsubresult);
          },

          // This function modifies the equation numbers.
          SeteqnumberFunction(parser, name) {
              // Get the macro parameters
              const star = parser.GetStar();                  // true if there is a *
              const optBrackets = parser.GetBrackets(name);   // contents of optional brackets
              const newsubequations = parser.GetArgument(name); // the subequations argument
              const neweqsection = parser.GetArgument(name); // the eq section argument
              const neweqnumber = parser.GetArgument(name);   // the eq number argument
              MathJax.config.subequations=newsubequations ;   // a string with boolean meaning
              MathJax.config.section=neweqsection ;           // a string with numeric meaning
              parser.tags.counter = parser.tags.allCounter = neweqnumber ;
          }

        });

        // Create the Lwarp-macros package
        Configuration.create('Lwarp-macros', {
          handler: {macro: ['Lwarp-macros']}
        });

        MathJax.startup.defaultReady();

        // For forward references:
        MathJax.startup.input[0].preFilters.add(({math}) => {
          if (math.inputData.recompile){
              MathJax.config.subequations = math.inputData.recompile.subequations;
              MathJax.config.section = math.inputData.recompile.section;
          }
        });
        MathJax.startup.input[0].postFilters.add(({math}) => {
          if (math.inputData.recompile){
              math.inputData.recompile.subequations = MathJax.config.subequations;
              math.inputData.recompile.section = MathJax.config.section;
          }
        });

          // For \left, \right with unicode-math:
          const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
          const {Symbol} = MathJax._.input.tex.Symbol;
          const {MapHandler} = MathJax._.input.tex.MapHandler;
          const delimiter = MapHandler.getMap('delimiter');
          delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
          delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
          delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
          delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
          delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
          delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
          delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
          delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
          delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
          delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
          delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
          delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
          delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
          delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
          delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
          delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
          delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
          delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
          delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
          delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
          delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
          delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
          delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
          delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
          delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
          delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
          delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
          delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
          delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
          delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
          delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
          delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
          delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
          delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
          delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
          delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
          delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
          delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
          delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
    }     // ready
  },      // startup

  tex: {
    packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
    tags: "ams",
         tagformat: {
             number: function (n) {
                 if(MathJax.config.subequations==0)
                     return(MathJax.config.section + n);
                 else
                     return(MathJax.config.section + String.fromCharCode(96+n));
             },
         },
  }
}
</script>

<script
    id="MathJax-script"
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>


</head>
<body>



<a id="notes_1-autopage-108"></a>
<nav class="topnavigation"><a href="notes_1.html" class="linkhome" >
Home</a></nav>

<header>

<p>
last updated: September 22, 2022
</p>

</header>



<div class="bodyandsidetoc">
<div class="sidetoccontainer">



<nav class="sidetoc">



<div class="sidetoctitle">

<p>
<span class="sidetocthetitle">Stochastic Processes and Financial Mathematics<br />
(part one)</span>
</p>

<p>
Contents
</p>
</div>



<div class="sidetoccontents">

<p>
<a href="notes_1.html" class="linkhome" >
Home</a>
</p>

</div>

</nav>

</div>



<main class="bodycontainer">



<section class="textbody">

<h1>Stochastic Processes and Financial Mathematics<br />
(part one)</h1>

<!--MathJax customizations:-->



<div class="hidden">

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\DeclareMathOperator {\var }{var}\)

\(\DeclareMathOperator {\cov }{cov}\)

\(\newcommand {\nN }{n \in \mathbb {N}}\)

\(\newcommand {\Br }{{\cal B}(\R )}\)

\(\newcommand {\F }{{\cal F}}\)

\(\newcommand {\ds }{\displaystyle }\)

\(\newcommand {\st }{\stackrel {d}{=}}\)

\(\newcommand {\uc }{\stackrel {uc}{\rightarrow }}\)

\(\newcommand {\la }{\langle }\)

\(\newcommand {\ra }{\rangle }\)

\(\newcommand {\li }{\liminf _{n \rightarrow \infty }}\)

\(\newcommand {\ls }{\limsup _{n \rightarrow \infty }}\)

\(\newcommand {\limn }{\lim _{n \rightarrow \infty }}\)

\(\def \ra {\Rightarrow }\)

\(\def \to {\rightarrow }\)

\(\def \iff {\Leftrightarrow }\)

\(\def \sw {\subseteq }\)

\(\def \wt {\widetilde }\)

\(\def \mc {\mathcal }\)

\(\def \mb {\mathbb }\)

\(\def \sc {\setminus }\)

\(\def \v {\textbf }\)

\(\def \p {\partial }\)

\(\def \E {\mb {E}}\)

\(\def \P {\mb {P}}\)

\(\def \R {\mb {R}}\)

\(\def \C {\mb {C}}\)

\(\def \N {\mb {N}}\)

\(\def \Q {\mb {Q}}\)

\(\def \Z {\mb {Z}}\)

\(\def \B {\mb {B}}\)

\(\def \~{\sim }\)

\(\def \-{\,;\,}\)

\(\def \|{\,|\,}\)

\(\def \qed {$\blacksquare $}\)

\(\def \1{\unicode {x1D7D9}}\)

\(\def \cadlag {c\&grave;{a}dl\&grave;{a}g}\)

\(\def \p {\partial }\)

\(\def \l {\left }\)

\(\def \r {\right }\)

\(\def \F {\mc {F}}\)

\(\def \G {\mc {G}}\)

\(\def \H {\mc {H}}\)

\(\def \Om {\Omega }\)

\(\def \om {\omega }\)

</div>

<p>
<!--
......     chapter Stochastic processes ......
-->
<h3 id="autosec-109">Chapter&nbsp;<span class="sectionnumber">4&#x2003;</span>Stochastic processes</h3>
<a id="notes_1-autopage-109"></a>
<a id="notes_1-autofile-16"></a>

<a id="chap:stoch_procs"></a>

<p>
In this chapter we introduce stochastic processes, with a selection of examples that are commonly used as building blocks in stochastic modelling. We show that these stochastic processes are closely connected to
martingales.
</p>
<div class="theorembodydefn">

<ul style="list-style-type:none">



<a id="autoid-80"></a>
<li>
<p>
<span class="theoremheaderplain">Definition 4.0.1</span> <a id="autoid-81" ></a >A stochastic process (in discrete time) is a sequence \((X_n)_{n=0}^\infty \) of random variables. We think of \(n\) as
‘time’.
</p>


</li>

</ul>

</div>

<p>
For example, a sequence of i.i.d.&nbsp;random variables is a stochastic process. A martingale is a stochastic process. A Markov chain (from MAS275, for those who took it) is a stochastic process. And so on.
</p>

<p>
For any stochastic process \((X_n)\) the <i>natural</i> or <i>generated filtration</i> of \((X_n)\) is the filtration given by
</p>

<p>
\[\mc {F}_n=\sigma (X_1,X_2,\ldots ,X_n).\]
</p>

<p>
Therefore, a random variable is \(\mc {F}_m\) measurable if it depends only on the behaviour of our stochastic process up until time \(m\).
</p>

<p>
From now on we adopt the convention (which is standard in the field of stochastic processes) that whenever we don’t specify a filtration explicitly we mean to use the generated filtration.
</p>
<!--
......   section Random walks ......
-->
<h4 id="autosec-111"><span class="sectionnumber">4.1&#x2003;</span>Random walks</h4>
<a id="notes_1-autopage-111"></a>



<p>
Random walks are stochastic processes that ‘walk around’ in space. We think of a particle that moves between vertices of \(\Z \). At each step of time, the particle chooses at random to either move up or down, for
example from \(x\) to \(x+1\) or \(x-1\).
</p>
<!--
......   subsection Symmetric random walk ......
-->
<h5 id="autosec-112">Symmetric random walk</h5>
<a id="notes_1-autopage-112"></a>



<a id="sec:ssrw"></a>

<p>
Let \((X_i)_{i=1}^\infty \) be a sequence of i.i.d.&nbsp;random variables where
</p>

<span class="hidden"> \(\seteqnumber{0}{4.}{0}\)</span>

<!--


                                                                          1
                                                  P[Xi = 1] = P[Xi = −1] = .                                                   (4.1)                        --><a id="eq:srw_step"></a><!--
                                                                          2
-->

<p>


\begin{equation}
\label {eq:srw_step} \P [X_i=1]=\P [X_i=-1]=\frac {1}{2}.
\end{equation}


</p>

<p>
The symmetric random walk is the stochastic process
</p>

<p>
\[S_n=\sum \limits _{i=1}^n X_i.\]
</p>

<p>
By convention, this means that \(S_0=0\). A <i>sample path</i> of \(S_n\), which means a sample of the sequence \(S_0,S_1,S_2,\ldots \), might look like:
</p>
<div class="center">

<p>


<a href="srw.jpg" target="_blank" ><img
      src="srw.jpg"
      style="
      width:282pt;
      "
      class="inlineimage"
      alt="(A simulation of a simple symmetric random walk)"
></a>
</p>
</div>

<p>
Note that when time is discrete \(t=0,1,2,\ldots \) it is standard to draw the location of the random walk (and other stochastic processes) as constant in between integer time points.
</p>

<p>
Because of <span class="textup">(<a href="Stochastic-processes.html#eq:srw_step">4.1</a>)</span>, the random walk is equally likely to move upwards or downwards. This case is known as the
‘symmetric’ random walk because, if \(S_0=0\), the two stochastic processes \(S_n\) and \(-S_n\) have the same distribution.
</p>

<p>
We have already seen (in Section <a href="Martingales.html#sec:martingales">3.3</a>) that \(S_n\) is a martingale, with respect to its generated filtration
</p>

<p>
\[\mc {F}_n=\sigma (X_1,\ldots ,X_n)=\sigma (S_1,\ldots ,S_n).\]
</p>

<p>
It should seem very natural that \((S_n)\) is a martingale – going upwards as much as downwards is ‘fair’.
</p>
<!--
......   subsection Asymmetric random walk ......
-->
<h5 id="autosec-114">Asymmetric random walk</h5>
<a id="notes_1-autopage-114"></a>



<a id="sec:asrw"></a>

<p>
Let \((X_i)_{i=1}^\infty \) be a sequence of i.i.d.&nbsp;random variables. Let \(p+q=1\) with \(p,q\in [0,1]\), \(p\neq q\) and suppose that
</p>

<p>
\[\P [X_i=1]=p,\hspace {1pc}\P [X_i=-1]=q.\]
</p>

<p>
The asymmetric random walk is the stochastic process
</p>

<p>
\[S_n=\sum \limits _{i=1}^n X_i.\]
</p>

<p>
The key difference to the symmetric random walk is that here we have \(p\neq q\) (the symmetric random walk has \(p=q=\frac 12\)). The asymmetric random is more likely to step upwards than downwards if
\(p&gt;q\), and vice versa if \(q&lt;p\). The technical term for this behaviour is <i>drift</i>. A sample path for the case \(p&gt;q\) might look like:
</p>
<div class="center">

<p>


<a href="brw.jpg" target="_blank" ><img
      src="brw.jpg"
      style="
      width:282pt;
      "
      class="inlineimage"
      alt="(A simulation of a simple asymmetric random walk)"
></a>
</p>
</div>

<p>
This is ‘unfair’, because of the drift upwards, so we should suspect that the asymmetric random walk is not a martingale. In fact,
</p>

<span class="hidden"> \(\seteqnumber{0}{4.}{1}\)</span>

<!--


                                                         n
                                                         X                n
                                                                          X
                                              E[Sn ] =         E[Xi ] =         (p − q) = n(p − q),                                               (4.2)               --><a id="eq:rw_drift"></a><!--
                                                         i=1              i=1

-->

<p>


\begin{equation}
\label {eq:rw_drift} \E [S_n]=\sum \limits _{i=1}^n\E [X_i]=\sum \limits _{i=1}^n(p-q)=n(p-q),
\end{equation}


</p>

<p>
whereas \(\E [S_0]=0\). Thus, Lemma <a href="Martingales.html#notmart">3.3.6</a> confirms that \(S_n\) is not a martingale. However, the process
</p>

<span class="hidden"> \(\seteqnumber{0}{4.}{2}\)</span>

<!--



                                                    Mn = Sn − n(p − q)                                                                   (4.3)                 --><a id="eq:drift_compensate"></a><!--

-->

<p>


\begin{equation}
\label {eq:drift_compensate} M_n=S_n-n(p-q)
\end{equation}


</p>

<p>
is a martingale. The key is that the term \(n(p-q)\) <i>compensates</i> for the drift and ‘restores fairness’.
</p>

<p>
We’ll now prove that \((M_n)\) is a martingale. Since \(X_i\in m\mc {F}_n\) for all \(i\leq n\), by Proposition <a href="Random-variables.html#itsallmeas">2.2.6</a> we have \(S_n-n(p-q)\in m\mc
{F}_n\). Since \(|X_i|\leq 1\) we have
</p>

<p>
\[|S_n-n(p-q)|\leq |S_n|+n|p-q|\leq n+n|p-q|\]
</p>

<p>
and hence \(M_n\) is bounded, so \(M_n\in L^1\). Lastly,
</p>
<span class="hidden"> \(\seteqnumber{0}{4.}{3}\)</span>



<!--



                                                                                E[Sn+1 − (n + 1)(p − q) | Fn ] = E[Sn+1 | Fn ] − (n + 1)(p − q)

                                                                                                              = E[Xn+1 | Fn ] + E[Sn | Fn ] − (n + 1)(p − q)

                                                                                                              = E[Xn+1 ] + Sn − (n + 1)(p − q)

                                                                                                              = (p − q) + Sn − (n + 1)(p − q)

                                                                                                              = Sn − n(p − q).



-->



<p>


\begin{align*}
\E [S_{n+1}-(n+1)(p-q)\|\mc {F}_n] &amp;=\E [S_{n+1}\|\mc {F}_n]-(n+1)(p-q)\\ &amp;=\E [X_{n+1}\|\mc {F}_n]+\E [S_n\|\mc {F}_n]-(n+1)(p-q)\\ &amp;=\E [X_{n+1}]+S_n-(n+1)(p-q)\\
&amp;=(p-q)+S_n-(n+1)(p-q)\\ &amp;=S_n-n(p-q).
\end{align*}
Therefore \(\E [M_{n+1}\|\mc {F}_n]=M_n\), and \((M_n)\) is a martingale.
</p>

</section>

</main>

</div>

<footer>

<p>
Copyright Nic Freeman, Sheffield University, last updated September 22, 2022
</p>

</footer>



<nav class="botnavigation"><a href="notes_1.html" class="linkhome" >
Home</a></nav>

</body>
</html>
