<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="author" content="Nic Freeman" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="description" content="MAS352/61023 Stochastic Processes and Financial Mathematics, Sheffield University, April 22, 2025." />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>MASx52 â€” Delta and Gamma Hedging</title>
<link rel="stylesheet" type="text/css" href="sans-serif-lwarp-sagebrush.css" />
<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
  subequations: "0",
  section: "",
  loader: {
    load: ['[tex]/tagformat', '[tex]/textmacros'],
  },
  startup: {
    ready() {
      // These would be replaced by import commands if you wanted to make
      // a proper extension.
      const Configuration = MathJax._.input.tex.Configuration.Configuration;
      const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
      const Macro = MathJax._.input.tex.Symbol.Macro;
      const TexError = MathJax._.input.tex.TexError.default;
      const ParseUtil = MathJax._.input.tex.ParseUtil.default;
      const expandable = MathJax._.util.Options.expandable;

        // Insert the replacement string into the TeX string, and check
        // that there haven't been too many maxro substitutions (prevents
        // infinite loops).
        const useArgument = (parser, text) => {
          parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
          parser.i = 0;
          if (++parser.macroCount > parser.configuration.options.maxMacros) {
            throw new TexError('MaxMacroSub1',
            'MathJax maximum macro substitution count exceeded; ' +
            'is there a recursive macro call?');
          }
        }

        // Create the command map for:
        //     \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
        new CommandMap('Lwarp-macros', {
          ifstar: 'IfstarFunction',
          ifnextchar: 'IfnextcharFunction',
          ifblank: 'IfblankFunction',
          ifstrequal: 'IfstrequalFunction',
          gsubstitute: 'GsubstituteFunction',
          seteqnumber: 'SeteqnumberFunction'
        }, {
          // This function implements an ifstar macro.
          IfstarFunction(parser, name) {
             const resultstar = parser.GetArgument(name);
             const resultnostar = parser.GetArgument(name);
             const star = parser.GetStar();                 // true if there is a *
             useArgument(parser, star ? resultstar : resultnostar);
          },

          // This function implements an ifnextchar macro.
          IfnextcharFunction(parser, name) {
            let whichchar = parser.GetArgument(name);
            if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
              // $ syntax highlighting
              whichchar = String.fromCodePoint(parseInt(whichchar));
            }
            const resultnextchar = parser.GetArgument(name);
            const resultnotnextchar = parser.GetArgument(name);
            const gotchar = (parser.GetNext() === whichchar);
            useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
          },

          // This function implements an ifblank macro.
          IfblankFunction(parser, name) {
            const blankarg = parser.GetArgument(name);
            const resultblank = parser.GetArgument(name);
            const resultnotblank = parser.GetArgument(name);
            const isblank = (blankarg.trim() == "");
            useArgument(parser, isblank ? resultblank : resultnotblank);
          },

          // This function implements an ifstrequal macro.
          IfstrequalFunction(parser, name) {
            const strequalfirst = parser.GetArgument(name);
            const strequalsecond = parser.GetArgument(name);
            const resultequal = parser.GetArgument(name);
            const resultnotequal = parser.GetArgument(name);
            const isequal = (strequalfirst == strequalsecond);
            useArgument(parser, isequal ? resultequal : resultnotequal);
          },

          // This function implements a gsub macro.
          GsubstituteFunction(parser, name) {
            const gsubfirst = parser.GetArgument(name);
            const gsubsecond = parser.GetArgument(name);
            const gsubthird = parser.GetArgument(name);
            let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
            useArgument(parser, gsubresult);
          },

          // This function modifies the equation numbers.
          SeteqnumberFunction(parser, name) {
              // Get the macro parameters
              const star = parser.GetStar();                  // true if there is a *
              const optBrackets = parser.GetBrackets(name);   // contents of optional brackets
              const newsubequations = parser.GetArgument(name); // the subequations argument
              const neweqsection = parser.GetArgument(name); // the eq section argument
              const neweqnumber = parser.GetArgument(name);   // the eq number argument
              MathJax.config.subequations=newsubequations ;   // a string with boolean meaning
              MathJax.config.section=neweqsection ;           // a string with numeric meaning
              parser.tags.counter = parser.tags.allCounter = neweqnumber ;
          }

        });

        // Create the Lwarp-macros package
        Configuration.create('Lwarp-macros', {
          handler: {macro: ['Lwarp-macros']}
        });

        MathJax.startup.defaultReady();

        // For forward references:
        MathJax.startup.input[0].preFilters.add(({math}) => {
          if (math.inputData.recompile){
              MathJax.config.subequations = math.inputData.recompile.subequations;
              MathJax.config.section = math.inputData.recompile.section;
          }
        });
        MathJax.startup.input[0].postFilters.add(({math}) => {
          if (math.inputData.recompile){
              math.inputData.recompile.subequations = MathJax.config.subequations;
              math.inputData.recompile.section = MathJax.config.section;
          }
        });

          // For \left, \right with unicode-math:
          const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
          const {Symbol} = MathJax._.input.tex.Symbol;
          const {MapHandler} = MathJax._.input.tex.MapHandler;
          const delimiter = MapHandler.getMap('delimiter');
          delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
          delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
          delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
          delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
          delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
          delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
          delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
          delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
          delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
          delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
          delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
          delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
          delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
          delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
          delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
          delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
          delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
          delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
          delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
          delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
          delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
          delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
          delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
          delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
          delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
          delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
          delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
          delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
          delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
          delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
          delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
          delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
          delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
          delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
          delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
          delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
          delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
          delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
          delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
    }     // ready
  },      // startup

  tex: {
    packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
    tags: "ams",
         tagformat: {
             number: function (n) {
                 if(MathJax.config.subequations==0)
                     return(MathJax.config.section + n);
                 else
                     return(MathJax.config.section + String.fromCharCode(96+n));
             },
         },
  }
}
</script>

<script
    id="MathJax-script"
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-J4222H8D03"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-J4222H8D03');
</script>
<!-- Google tag (gtag.js) -->


</head>
<body>



<a id="notes_2-autopage-160"></a>
<nav class="topnavigation"><a href="notes_2.html" class="linkhome" >
Home</a></nav>

<header>

<p>
last updated: April 22, 2025
</p>

</header>



<div class="bodyandsidetoc">
<div class="sidetoccontainer">



<nav class="sidetoc">



<div class="sidetoctitle">

<p>
<span class="sidetocthetitle">Stochastic Processes and Financial Mathematics<br />
(part two)</span>
</p>

<p>
Contents
</p>
</div>



<div class="sidetoccontents">

<p>
<a href="notes_2.html" class="linkhome" >
Home</a>
</p>

</div>

</nav>

</div>



<main class="bodycontainer">



<section class="textbody">

<h1>Stochastic Processes and Financial Mathematics<br />
(part two)</h1>

<!--MathJax customizations:-->
<div data-nosnippet
      style="display:none"
>

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\DeclareMathOperator {\var }{var}\)

\(\DeclareMathOperator {\cov }{cov}\)

\(\DeclareMathOperator {\indeg }{deg_{in}}\)

\(\DeclareMathOperator {\outdeg }{deg_{out}}\)

\(\newcommand {\nN }{n \in \mathbb {N}}\)

\(\newcommand {\Br }{{\cal B}(\R )}\)

\(\newcommand {\F }{{\cal F}}\)

\(\newcommand {\ds }{\displaystyle }\)

\(\newcommand {\st }{\stackrel {d}{=}}\)

\(\newcommand {\uc }{\stackrel {uc}{\rightarrow }}\)

\(\newcommand {\la }{\langle }\)

\(\newcommand {\ra }{\rangle }\)

\(\newcommand {\li }{\liminf _{n \rightarrow \infty }}\)

\(\newcommand {\ls }{\limsup _{n \rightarrow \infty }}\)

\(\newcommand {\limn }{\lim _{n \rightarrow \infty }}\)

\(\def \ra {\Rightarrow }\)

\(\def \to {\rightarrow }\)

\(\def \iff {\Leftrightarrow }\)

\(\def \sw {\subseteq }\)

\(\def \wt {\widetilde }\)

\(\def \mc {\mathcal }\)

\(\def \mb {\mathbb }\)

\(\def \sc {\setminus }\)

\(\def \v {\textbf }\)

\(\def \p {\partial }\)

\(\def \E {\mb {E}}\)

\(\def \P {\mb {P}}\)

\(\def \R {\mb {R}}\)

\(\def \C {\mb {C}}\)

\(\def \N {\mb {N}}\)

\(\def \Q {\mb {Q}}\)

\(\def \Z {\mb {Z}}\)

\(\def \B {\mb {B}}\)

\(\def \~{\sim }\)

\(\def \-{\,;\,}\)

\(\def \|{\,|\,}\)

\(\def \qed {$\blacksquare $}\)

\(\def \1{\unicode {x1D7D9}}\)

\(\def \cadlag {c\&grave;{a}dl\&grave;{a}g}\)

\(\def \p {\partial }\)

\(\def \l {\left }\)

\(\def \r {\right }\)

\(\def \F {\mc {F}}\)

\(\def \G {\mc {G}}\)

\(\def \H {\mc {H}}\)

\(\def \Om {\Omega }\)

\(\def \om {\omega }\)

\(\def \Vega {\mc {V}}\)

</div>

<!--
......     section Delta and Gamma Hedging ......
-->
<h4 id="autosec-161"><span class="sectionnumber">16.3&#x2003;</span>Delta and Gamma Hedging</h4>
<a id="notes_2-autopage-161"></a>
<a id="notes_2-autofile-28"></a>

<a id="s:dg_hedge"></a>

<p>
As in the previous section, consider a portfolio consisting of both options, stock and cash, whose value at time \(t\) is given by \(F(t,S_t)\). In this section we will make heavy use of the first two Greeks,
\(\Delta (t,S_t)=\frac {\p F}{\p s}(t,S_t)\) and \(\Gamma (t,S_t)=\frac {\p ^2 F}{\p s^2}(t,S_t)\).
</p>

<p>
In this section we will need to consider several portfolios at once. If \(F(t,S_t)\) is the value of a portfolio at time \(t\) then we say that \(F\) is the <i>price function</i> of this portfolio, and we write the
corresponding \(\Delta \) and \(\Gamma \) as
</p>

<p>
\[\Delta _F=\frac {\p F}{\p s},\hspace {5pc}\Gamma _F=\frac {\p ^2 F}{\p s^2}.\]
</p>

<p>
We focus first on \(\Delta _F\).
</p>
<div class="theorembodydefn">

<ul class="list" style="list-style-type:none">



<a id="autoid-135"></a>
<li>
<p>
<span class="listmarker"> <span class="theoremheaderplain">Definition 16.3.1</span></span> <a id="autoid-136" ></a >A portfolio with price function \(F\) is said to be <b>delta neutral</b> at
time \(t\) if \(\Delta _F(t,S_t)=0\).
</p>


</li>

</ul>

</div>

<p>
Let us think about delta neutrality for a moment. In words, \(\Delta _F(t,S_t)=0\) says that the derivative, with respect to the stock price, of the value of the replicating portfolio \(F\), is zero. This means that
if \(S_t\) where to vary (slightly), we would not expect the value of \(F\) to vary much. In other words, to some extent, the value of \(F\) is not exposed to changes in the price of the underlying stock; which is a
good thing, since it means the holder of the portfolio takes less risk. With this motivation, we will now look at a hedging strategy that tries to keep \(\Delta \approx 0\).
</p>

<p>
For a contingent claim \(\Phi (S_T)\), let \(F(t,S_t)\) be the value of the â€˜usualâ€™ hedging portfolio \(h_t=(x_t,y_t)\), consisting of just cash and stocks, that is provided by Theorem <a
href="notes_2.html#??">??</a>. Such a portfolio is typically not delta neutral. We consider including an amount \(z_t\) of some derivative (say, a call option) with itself has hedging portfolio with value
\(Z(t,S_t)\). The value of our new portfolio is therefore
</p>

<p>
\[V(t,S_t)=F(t,S_t)+z_tZ(t,S_t).\]
</p>

<p>
We would like this new portfolio to be delta neutral, say at time \(t\). That is, we would like \(\Delta _V=\frac {\p V}{\p s}=0\), which gives us the equation
</p>

<span class="hidden"> \(\seteqnumber{0}{16.}{1}\)</span>

<!--


                                                            âˆ‚F      âˆ‚Z
                                                               + zt    =0                                                              (16.2)                              --><a id="eq:zt_delta_hedge"></a><!--
                                                            âˆ‚s      âˆ‚s
-->

<p>


\begin{equation}
\label {eq:zt_delta_hedge} \frac {\p F}{\p s}+z_t\frac {\p Z}{\p s}=0
\end{equation}


</p>

<p>
and solving for \(z_t\) we see that we should hold
</p>

<p>
\[z_t=-\frac {\Delta _F}{\Delta _Z}\]
</p>

<p>
units of the derivative. Adding this amount of the deriative into our usual replicating portfolio, with the aim of having \(\Delta _V=0\), is known as a <b>delta hedge</b>.
</p>
<div class="theorembodyexample">

<ul class="list" style="list-style-type:none">



<a id="autoid-137"></a>
<li>
<p>
<span class="listmarker"> <span class="theoremheaderplain">Example 16.3.2</span></span> <a id="autoid-138" ></a ><a id="ex:delta_hedge"></a> Suppose that we have entered into a contract,
as the seller, where the value to the other party in the contract (the buyer) at time \(t\) is given by \(P(t,S_t)\). We want to delta hedge our position. So, we have \(F(t,S_t)=-P(t,S_t)\).
</p>

<p>
Suppose that the â€˜derivativeâ€™ that we wish to use for our delta hedge is the underlying stock itself, which of course has price function
</p>

<p>
\[Z(t,S_t)=S_t,\]
</p>

<p>
giving \(Z(t,s)=s\). Then \(\frac {\p V}{\p s}=0\) when
</p>

<p>
\[\frac {\p F}{\p s}+z_t\frac {\p Z}{\p s}=-\frac {\p P}{\p s}+z_t=0\]
</p>

<p>
and we see that we need to hold an additional
</p>

<p>
\[z_t=\Delta _P\]
</p>

<p>
units of stock in order to delta hedge.
</p>


</li>

</ul>

</div>

<p>
There is a spanner in the works here. The value of \(z_t\) changes with time. If, at time \(t\), we delta hedge using \(z_t\), then at time \(t+\epsilon \) we will discover that \(z_{t+\epsilon }\) is slightly
different from \(z_t\) and our delta hedge is no longer working. On the other hand, if we continually adapt our portfolio to precisely match \(z_t\) then we will suffer high transaction costs.
</p>

<p>
To handle this issue, there is a procedure known as <b>discrete rebalanced delta hedge</b>. We explain it in the setting of Example <a href="notes_2.html#??">??</a>, where we have sold one unit of an
option with price function \(P\), and wish to delta hedge the sale.
</p>

<p>
First, we fix some \(\epsilon &gt;0\). Then:
</p>
<ul class="itemize" style="list-style-type:none">


<li>
<p>
<span class="listmarker">â€¢</span> At time \(t=0\), sell one unit of an option with price \(P\).
</p>


</li>
<li>


<p>
<span class="listmarker">â€¢</span> Compute \(z_t=\Delta _P(t,S_t)\) (using Theorem <a href="notes_2.html#??">??</a>) at \(t=0\) and buy (or sell) this many units of stock.
</p>


</li>
<li>


<p>
<span class="listmarker">â€¢</span> Wait for time \(\epsilon \). Recompute \(z_t=\Delta _P(t,S_t)\) at time \(t=\epsilon \), then buy/sell stock to re-balance the amount of â€˜extraâ€™ stock that we hold,
to match this new amount.
</p>


</li>
<li>


<p>
<span class="listmarker">â€¢</span> Repeat the rebalancing at each time \(t=\epsilon ,2\epsilon ,3\epsilon ,4\epsilon ,\ldots \) and so on.
</p>
</li>
</ul>

<p>
Of course, a smaller \(\epsilon \) results in closer approximation of \(z_t\approx \Delta _P(t,S_t)\) and (consequently) a more effective delta hedge, but with higher transaction costs; a larger \(\epsilon \)
results in less effective delta hedge but lower transaction costs. This is natural â€“ we canâ€™t expect to reduce risk for free.
</p>
<div class="theorembodyremark">

<ul class="list" style="list-style-type:none">



<a id="autoid-139"></a>
<li>
<p>
<span class="listmarker"> <span class="theoremheaderplain">Remark 16.3.3</span></span> <a id="autoid-140" ></a >\(\offsyl \) It can be shown that as \(\epsilon \to 0\), the resulting
portfolio approximates the true delta hedged portfolio that corresponds, at all times, to holding \(z_t\) extra stock.
</p>


</li>

</ul>

</div>

<p>
Of course, there is no need for all of our rebalancing time intervals to have length \(\epsilon \). In fact, if \(\Delta _P\) is changing rapidly then we will need to rebalance frequently in order to keep \(z_t\approx
\Delta _P(t,S_t)\), but if \(\Delta _P\) is relatively stable then weâ€™ll want to rebalance infrequently and spend less on transaction costs. This observation leads us on to the idea of \(\Gamma \) neutrality.
</p>
<div class="theorembodydefn">

<ul class="list" style="list-style-type:none">



<a id="autoid-141"></a>
<li>
<p>
<span class="listmarker"> <span class="theoremheaderplain">Definition 16.3.4</span></span> <a id="autoid-142" ></a >A portfolio with price function \(F\) is said to be <b>gamma neutral</b> at
time \(t\) if \(\Gamma _F(t,S_t)=0\).
</p>


</li>

</ul>

</div>

<p>
The key idea is that \(\Gamma _P(t,S_t)=\frac {\p }{\p s}\Delta _P(t,S_t)\) measures how quickly \(\Delta _P\) changes in response to changes in the underlying stock price \(S_t\). When \(\Gamma
_P\approx 0\), we have that \(\Delta _P\) does not change quickly in response to small changes in the stock price. For this reason, it is advantageous to hold portfolios which are delta neutral <i>and</i> gamma
neutral. How to achieve this?
</p>

<p>
We now find ourselves wanting to augment a replicating portfolio (that, recall, has price function \(F(t,S_t)\)) into a portfolio with price function \(V(t,S_t)\) in such a way as both
</p>

<span class="hidden"> \(\seteqnumber{0}{16.}{2}\)</span>

<!--


                                                     âˆ‚V                      âˆ‚2V
                                              âˆ†V =      = 0,          Î“V =       = 0.                                               (16.3)                               --><a id="eq:delta_gamma_hedge"></a><!--
                                                     âˆ‚s                      âˆ‚s2
-->

<p>


\begin{equation}
\label {eq:delta_gamma_hedge} \Delta _V=\frac {\p V}{\p s}=0,\hspace {3pc}\Gamma _V=\frac {\p ^2 V}{\p s^2}=0.
\end{equation}


</p>

<p>
It should be intuitively clear that, because we now have two conditions to satisfy, weâ€™ll need to consider adding in two extra quantities in order to achieve this. So, consider adding in \(w_t\) of some derivative with
price function \(W(t,S_t)\) and \(z_t\) of some other derivative with price function \(Z(t,S_t)\). Then \(V(t,S_t)=F(t,S_t)+w_tW(t,S_t)+z_tZ(t,S_t)\) and to satisfy <span class="textup">(<a
href="notes_2.html#??">??</a>)</span> we need that both
</p>
<span class="hidden"> \(\seteqnumber{0}{16.}{3}\)</span>



<!--



                                                                                                âˆ†F + wt âˆ†W + zt âˆ†Z = 0

                                                                                                 Î“F + wt Î“W + zt Î“Z = 0.                           (16.4)                         --><a id="eq:gamma_eqs"></a><!--



-->



<p>


\begin{align}
\Delta _F+w_t\Delta _W+z_t\Delta _Z&amp;=0 \notag \\ \Gamma _F+w_t\Gamma _W+z_t\Gamma _Z&amp;=0.                       \label {eq:gamma_eqs}
\end{align}
We could solve this pair of linear equations to find formulae for \(w_t\) and \(z_t\), in terms of the \(\Delta \)s and \(\Gamma \)s. Since the formulae themselves are not particularly interesting to see, we wonâ€™t
bother. Including the resulting amounts \(w_t\) of \(W\), plus \(z_t\) of \(Z\), into a portfolio, in order to achieve <span class="textup">(<a href="notes_2.html#??">??</a>)</span> is known as a
<b>gamma hedge</b>.
</p>
<div class="theorembodyremark">

<ul class="list" style="list-style-type:none">



<a id="autoid-143"></a>
<li>
<p>
<span class="listmarker"> <span class="theoremheaderplain">Remark 16.3.5</span></span> <a id="autoid-144" ></a >Of course, \(z_t\) and \(w_t\) vary with time, which means that implementing a
gamma hedge requires a discrete rebalancing scheme, in the same spirit as we described for the delta hedge. In the interests of brevity, we donâ€™t go into any further details on this point.
</p>

<p>
Delta and gamma hedging are the basis for many of the hedging strategies that are employed by investment banks and hedge funds.
</p>


</li>

</ul>

</div>

</section>

</main>

</div>

<footer>

<p>
Copyright Nic Freeman, Sheffield University, last updated April 22, 2025
</p>

</footer>



<nav class="botnavigation"><a href="notes_2.html" class="linkhome" >
Home</a></nav>

</body>
</html>
