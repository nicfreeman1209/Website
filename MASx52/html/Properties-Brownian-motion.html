<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="author" content="Nic Freeman" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="description" content="MAS352/61023 Stochastic Processes and Financial Mathematics, Sheffield University, April 22, 2025." />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>MASx52 â€” Properties of Brownian motion</title>
<link rel="stylesheet" type="text/css" href="sans-serif-lwarp-sagebrush.css" />
<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
  subequations: "0",
  section: "",
  loader: {
    load: ['[tex]/tagformat', '[tex]/textmacros'],
  },
  startup: {
    ready() {
      // These would be replaced by import commands if you wanted to make
      // a proper extension.
      const Configuration = MathJax._.input.tex.Configuration.Configuration;
      const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
      const Macro = MathJax._.input.tex.Symbol.Macro;
      const TexError = MathJax._.input.tex.TexError.default;
      const ParseUtil = MathJax._.input.tex.ParseUtil.default;
      const expandable = MathJax._.util.Options.expandable;

        // Insert the replacement string into the TeX string, and check
        // that there haven't been too many maxro substitutions (prevents
        // infinite loops).
        const useArgument = (parser, text) => {
          parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
          parser.i = 0;
          if (++parser.macroCount > parser.configuration.options.maxMacros) {
            throw new TexError('MaxMacroSub1',
            'MathJax maximum macro substitution count exceeded; ' +
            'is there a recursive macro call?');
          }
        }

        // Create the command map for:
        //     \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
        new CommandMap('Lwarp-macros', {
          ifstar: 'IfstarFunction',
          ifnextchar: 'IfnextcharFunction',
          ifblank: 'IfblankFunction',
          ifstrequal: 'IfstrequalFunction',
          gsubstitute: 'GsubstituteFunction',
          seteqnumber: 'SeteqnumberFunction'
        }, {
          // This function implements an ifstar macro.
          IfstarFunction(parser, name) {
             const resultstar = parser.GetArgument(name);
             const resultnostar = parser.GetArgument(name);
             const star = parser.GetStar();                 // true if there is a *
             useArgument(parser, star ? resultstar : resultnostar);
          },

          // This function implements an ifnextchar macro.
          IfnextcharFunction(parser, name) {
            let whichchar = parser.GetArgument(name);
            if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
              // $ syntax highlighting
              whichchar = String.fromCodePoint(parseInt(whichchar));
            }
            const resultnextchar = parser.GetArgument(name);
            const resultnotnextchar = parser.GetArgument(name);
            const gotchar = (parser.GetNext() === whichchar);
            useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
          },

          // This function implements an ifblank macro.
          IfblankFunction(parser, name) {
            const blankarg = parser.GetArgument(name);
            const resultblank = parser.GetArgument(name);
            const resultnotblank = parser.GetArgument(name);
            const isblank = (blankarg.trim() == "");
            useArgument(parser, isblank ? resultblank : resultnotblank);
          },

          // This function implements an ifstrequal macro.
          IfstrequalFunction(parser, name) {
            const strequalfirst = parser.GetArgument(name);
            const strequalsecond = parser.GetArgument(name);
            const resultequal = parser.GetArgument(name);
            const resultnotequal = parser.GetArgument(name);
            const isequal = (strequalfirst == strequalsecond);
            useArgument(parser, isequal ? resultequal : resultnotequal);
          },

          // This function implements a gsub macro.
          GsubstituteFunction(parser, name) {
            const gsubfirst = parser.GetArgument(name);
            const gsubsecond = parser.GetArgument(name);
            const gsubthird = parser.GetArgument(name);
            let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
            useArgument(parser, gsubresult);
          },

          // This function modifies the equation numbers.
          SeteqnumberFunction(parser, name) {
              // Get the macro parameters
              const star = parser.GetStar();                  // true if there is a *
              const optBrackets = parser.GetBrackets(name);   // contents of optional brackets
              const newsubequations = parser.GetArgument(name); // the subequations argument
              const neweqsection = parser.GetArgument(name); // the eq section argument
              const neweqnumber = parser.GetArgument(name);   // the eq number argument
              MathJax.config.subequations=newsubequations ;   // a string with boolean meaning
              MathJax.config.section=neweqsection ;           // a string with numeric meaning
              parser.tags.counter = parser.tags.allCounter = neweqnumber ;
          }

        });

        // Create the Lwarp-macros package
        Configuration.create('Lwarp-macros', {
          handler: {macro: ['Lwarp-macros']}
        });

        MathJax.startup.defaultReady();

        // For forward references:
        MathJax.startup.input[0].preFilters.add(({math}) => {
          if (math.inputData.recompile){
              MathJax.config.subequations = math.inputData.recompile.subequations;
              MathJax.config.section = math.inputData.recompile.section;
          }
        });
        MathJax.startup.input[0].postFilters.add(({math}) => {
          if (math.inputData.recompile){
              math.inputData.recompile.subequations = MathJax.config.subequations;
              math.inputData.recompile.section = MathJax.config.section;
          }
        });

          // For \left, \right with unicode-math:
          const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
          const {Symbol} = MathJax._.input.tex.Symbol;
          const {MapHandler} = MathJax._.input.tex.MapHandler;
          const delimiter = MapHandler.getMap('delimiter');
          delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
          delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
          delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
          delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
          delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
          delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
          delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
          delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
          delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
          delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
          delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
          delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
          delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
          delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
          delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
          delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
          delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
          delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
          delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
          delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
          delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
          delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
          delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
          delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
          delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
          delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
          delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
          delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
          delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
          delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
          delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
          delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
          delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
          delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
          delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
          delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
          delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
          delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
          delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
    }     // ready
  },      // startup

  tex: {
    packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
    tags: "ams",
         tagformat: {
             number: function (n) {
                 if(MathJax.config.subequations==0)
                     return(MathJax.config.section + n);
                 else
                     return(MathJax.config.section + String.fromCharCode(96+n));
             },
         },
  }
}
</script>

<script
    id="MathJax-script"
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-J4222H8D03"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-J4222H8D03');
</script>
<!-- Google tag (gtag.js) -->


</head>
<body>



<a id="notes_2-autopage-31"></a>
<nav class="topnavigation"><a href="notes_2.html" class="linkhome" >
Home</a></nav>

<header>

<p>
last updated: April 22, 2025
</p>

</header>



<div class="bodyandsidetoc">
<div class="sidetoccontainer">



<nav class="sidetoc">



<div class="sidetoctitle">

<p>
<span class="sidetocthetitle">Stochastic Processes and Financial Mathematics<br />
(part two)</span>
</p>

<p>
Contents
</p>
</div>



<div class="sidetoccontents">

<p>
<a href="notes_2.html" class="linkhome" >
Home</a>
</p>

</div>

</nav>

</div>



<main class="bodycontainer">



<section class="textbody">

<h1>Stochastic Processes and Financial Mathematics<br />
(part two)</h1>

<!--MathJax customizations:-->
<div data-nosnippet
      style="display:none"
>

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\DeclareMathOperator {\var }{var}\)

\(\DeclareMathOperator {\cov }{cov}\)

\(\DeclareMathOperator {\indeg }{deg_{in}}\)

\(\DeclareMathOperator {\outdeg }{deg_{out}}\)

\(\newcommand {\nN }{n \in \mathbb {N}}\)

\(\newcommand {\Br }{{\cal B}(\R )}\)

\(\newcommand {\F }{{\cal F}}\)

\(\newcommand {\ds }{\displaystyle }\)

\(\newcommand {\st }{\stackrel {d}{=}}\)

\(\newcommand {\uc }{\stackrel {uc}{\rightarrow }}\)

\(\newcommand {\la }{\langle }\)

\(\newcommand {\ra }{\rangle }\)

\(\newcommand {\li }{\liminf _{n \rightarrow \infty }}\)

\(\newcommand {\ls }{\limsup _{n \rightarrow \infty }}\)

\(\newcommand {\limn }{\lim _{n \rightarrow \infty }}\)

\(\def \ra {\Rightarrow }\)

\(\def \to {\rightarrow }\)

\(\def \iff {\Leftrightarrow }\)

\(\def \sw {\subseteq }\)

\(\def \wt {\widetilde }\)

\(\def \mc {\mathcal }\)

\(\def \mb {\mathbb }\)

\(\def \sc {\setminus }\)

\(\def \v {\textbf }\)

\(\def \p {\partial }\)

\(\def \E {\mb {E}}\)

\(\def \P {\mb {P}}\)

\(\def \R {\mb {R}}\)

\(\def \C {\mb {C}}\)

\(\def \N {\mb {N}}\)

\(\def \Q {\mb {Q}}\)

\(\def \Z {\mb {Z}}\)

\(\def \B {\mb {B}}\)

\(\def \~{\sim }\)

\(\def \-{\,;\,}\)

\(\def \|{\,|\,}\)

\(\def \qed {$\blacksquare $}\)

\(\def \1{\unicode {x1D7D9}}\)

\(\def \cadlag {c\&grave;{a}dl\&grave;{a}g}\)

\(\def \p {\partial }\)

\(\def \l {\left }\)

\(\def \r {\right }\)

\(\def \F {\mc {F}}\)

\(\def \G {\mc {G}}\)

\(\def \H {\mc {H}}\)

\(\def \Om {\Omega }\)

\(\def \om {\omega }\)

\(\def \Vega {\mc {V}}\)

</div>

<!--
......     section Properties of Brownian motion ......
-->
<h4 id="autosec-32"><span class="sectionnumber">11.4&#x2003;</span>Properties of Brownian motion</h4>
<a id="notes_2-autopage-32"></a>
<a id="notes_2-autofile-5"></a>

<p>
We now examine some of the more detailed properties of Brownian motion. Recall that \(B_t\) denotes a standard Brownian motion.
</p>
<!--
......   subsubsection Symmetry ......
-->
<h6 id="autosec-33">Symmetry</h6>
<a id="notes_2-autopage-33"></a>



<p>
The normal distribution \(Z\sim N(0,\sigma ^2)\) is symmetric about \(0\), in the sense that \(-Z\) also has the distribution \(N(0,\sigma ^2)\). This symmetry about \(0\) is also present in Brownian motion.
</p>
<div class="theorembodylemma">

<ul class="list" style="list-style-type:none">



<a id="autoid-21"></a>
<li>
<p>
<span class="listmarker"> <span class="theoremheaderplain">Lemma 11.4.1</span></span> <a id="autoid-22" ></a ><a id="l:bm_sym"></a> The stochastic process \(W_t=-B_t\) is a standard
Brownian motion.
</p>


</li>

</ul>

</div>

<p>
<span class="textsc">Proof:</span><span style="width:5.38533pt; display:inline-block"><!----></span> We must check that \(W_t=-B_t\) satisfies the three defining properties of Brownian motion.
By the first property, \(B_t\) is almost surely continuous, hence \(-B_t\) is also almost surely continuous. Also, for \(0\leq u\leq t\) we have
</p>

<p>
\[W_t-W_u=-(B_t-B_u).\]
</p>

<p>
Since, by the second property, \(B_t-B_u\) is independent of \(\mc {F}_u\), so is \(W_t-W_u\), and we have
</p>

<p>
\[\sigma (W_v\-v\leq u)=\sigma (-W_v\-v\leq u)=\sigma (B_v\-v\leq u)=\mc {F}_u.\]
</p>

<p>
Thus \(W_t-W_u\) is independent of \(\sigma (W_v\-v\leq u)\).
</p>

<p>
Lastly, if \(Z\sim N(0,t)\) then, using the symmetry of normal random variables, \(-Z\sim N(0,t)\), so we have
</p>

<p>
\[W_t-W_u=-(B_t-B_u)\sim N(0,t-u)\]
</p>

<p>
by the third property. Hence, all three properties also hold for \((W_t)\), so \(W_t\) is a Brownian motion. Since \(W_0=-B_0=0\), we have that \((W_t)\) is a standard Brownian motion.
&#x2003;&#x2003;&#x220E;
</p>

<p>
Lemma <a href="notes_2.html#??">??</a> is often referred to as an example of a â€˜self-symmetryâ€™ of Brownian motion, meaning a transformation of a Brownian motion that results in another Brownian motion.
It turns out that Brownian motion has many self-symmetries, and they are very important to the theory of Brownian motion.
</p>
<!--
......    subsubsection Non-differentiability ......
-->
<h6 id="autosec-35">Non-differentiability</h6>
<a id="notes_2-autopage-35"></a>



<p>
As weâ€™ve seen in Section <a href="notes_2.html#??">??</a>, the paths of Brownian motion look very jagged and erratic. We can express this idea formally: the sample paths of Brownian motion are not
differentiable!
</p>
<div class="theorembodylemma">

<ul class="list" style="list-style-type:none">



<a id="autoid-23"></a>
<li>
<p>
<span class="listmarker"> <span class="theoremheaderplain">Lemma 11.4.2</span></span> <a id="autoid-24" ></a ><a id="l:bm_non_diff"></a> Let \(t\in [0,\infty )\). Almost surely, the
function \(t\mapsto B_t\) is not differentiable at \(t\).
</p>


</li>

</ul>

</div>

<p>
<span class="textsc">Proof:</span><span style="width:5.38533pt; display:inline-block"><!----></span> Using the second property of Brownian motion, and the scaling properties of normal random
variables,
</p>

<p>
\[\frac {B_{t+h}-B_t}{h}\;\sim \;\frac {B_h}{h}\;\sim \; \frac {X}{\sqrt {h}}.\]
</p>

<p>
where \(X\sim N(0,1)\). Note that \(X\) is positive half the time and negative half the time (and \(\P [X=0]=0\)). Hence, as \(h\to 0\), we obtain that
</p>

<span class="hidden"> \(\seteqnumber{0}{11.}{5}\)</span>

<!--

                                                             ï£±
                                                                      with probability 1/2,
                                                             ï£´
                                               X a.s.        ï£²âˆž
                                                             ï£´
                                               âˆš â†’ Xâˆž =                                                                                   (11.6)                               --><a id="eq:limXsqrth"></a><!--
                                                h       ï£³âˆ’âˆž
                                                        ï£´
                                                        ï£´             with probability 1/2.

-->

<p>


\begin{equation}
\label {eq:limXsqrth} \frac {X}{\sqrt {h}}\stackrel {a.s.}{\to } X_\infty = \begin{cases} \infty &amp; \text { with probability }1/2, \\ -\infty &amp; \text { with probability
}1/2.    \end {cases}
\end{equation}


</p>

<p>
Form Lemma <a href="Convergence-random-variables.html#l:conv_modes">6.1.2</a>, almost sure convergence implies convergence in distribution, so this limit also holds in distribution. Since \(\frac
{B_{t+h}-B_t}{h}\) has the same distribution as \(\frac {X}{\sqrt {h}}\), we obtain that \(\frac {B_{t+h}-B_t}{h}\) converges in distribution to \(X_\infty .\)
</p>

<p>
Consider the event \(E=\{B_t\text { is differentiable at }t\}\). When the event \(E\) occurs, \(\frac {B_{t+h}-B_t}{h}\) converges to a finite quantity as \(h\to 0\). However, we saw above that
\(\frac {B_{t+h}-B_t}{h}\) had the limit \(X_\infty \), with \(\P [X_\infty \in \{\infty ,-\infty \}]=1\), so the probability that this limit is a finite quantity is zero. Therefore, \(\P [E]=0\).
&#x2003;&#x2003;&#x220E;
</p>

<p>
Pure mathematicians discovered functions that were nowhere differentiable at around the start of the \(20^{th}\) century. At first, they were widely thought to be mathematical curiosities, with little or no
importance in the â€˜realâ€™ world. A few decades later, the discovery that Brownian motion played a key role in physics, biology and mathematical finance had reversed this viewpoint.
</p>
<!--
......   subsubsection Relationship to martingales ......
-->
<h6 id="autosec-37">Relationship to martingales</h6>
<a id="notes_2-autopage-37"></a>



<p>
It turns out that there are many martingales associated to Brownian motion. Hereâ€™s two, with two more to come in exercise <a href="notes_2.html#??">??</a>, and others in later sections of the course.
</p>
<div class="theorembodylemma">

<ul class="list" style="list-style-type:none">



<a id="autoid-25"></a>
<li>
<p>
<span class="listmarker"> <span class="theoremheaderplain">Lemma 11.4.3</span></span> <a id="autoid-26" ></a ><a id="l:bm_mart"></a> Brownian motion is a martingale.
</p>


</li>

</ul>

</div>

<p>
<span class="textsc">Proof:</span><span style="width:5.38533pt; display:inline-block"><!----></span> It is enough to look at the case \((B_t)\) of standard Brownian motion, since adding and
subtracting a deterministic constant does not change if a process is a martingale.
</p>

<p>
Since \(B_t\sim N(0,t)\) we have \(\var (B_t)&lt;\infty \), which implies that \(B_t\in L^1\). Since the filtration \((\mc {F}_t)\) is the generated filtration of \(B_t\), is immediate that \(B_t\) is
adapted. Lastly, for any \(0\leq u\leq t\) we have
</p>
<span class="hidden"> \(\seteqnumber{0}{11.}{6}\)</span>



<!--



                                                                                     E[Bt | Fu ] = E[Bt âˆ’ Bu | Fu ] + E[Bu | Fu ]

                                                                                                = E[Bt âˆ’ Bu ] + Bu

                                                                                                = Bu .



-->



<p>


\begin{align*}
\E [B_t\|\mc {F}_u]&amp;=\E [B_t-B_u\|\mc {F}_u]+\E [B_u\|\mc {F}_u]\\ &amp;=\E [B_t-B_u]+B_u\\ &amp;=B_u.
\end{align*}
Here, we use the properties of Brownian motion: \(B_t-B_s\) is independent of \(\mc {F}_u\) and \(\E [B_t]=\E [B_u]=0\). &#x2003;&#x2003;&#x220E;
</p>
<div class="theorembodylemma">

<ul class="list" style="list-style-type:none">



<a id="autoid-27"></a>
<li>
<p>
<span class="listmarker"> <span class="theoremheaderplain">Lemma 11.4.4</span></span> <a id="autoid-28" ></a ><a id="l:bm2_mart"></a> \(B_t^2-t\) is a martingale
</p>


</li>

</ul>

</div>

<p>
<span class="textsc">Proof:</span><span style="width:5.38533pt; display:inline-block"><!----></span> Since \(B_t\sim N(0,t)\) we have \(\var (B_t)&lt;\infty \), which implies \(B^2_t\in
L^1\). Hence also \(B_t^2-t\in L^1\). Since \(B_t^2-t\) is a deterministic function of \(B_t\), we have that \(B_t^2-t\) is adapted to the generated filtration of \(B_t\). Lastly, for \(0\leq u\leq t\),
</p>
<span class="hidden"> \(\seteqnumber{0}{11.}{6}\)</span>



<!--



                                                                           E[Bt2 âˆ’ t | Fu ] = E[(Bt âˆ’ Bu )2 + 2Bt Bu âˆ’ Bu2 | Fu ] âˆ’ t

                                                                                          = E[(Bt âˆ’ Bu )2 | Fu ] + 2Bu E[Bt | Fu ] âˆ’ Bu2 âˆ’ t

                                                                                          = E[(Bt âˆ’ Bu )2 ] + 2Bu2 âˆ’ Bu2 âˆ’ t

                                                                                          = (t âˆ’ u) + Bu2 âˆ’ t

                                                                                          = Bu2 âˆ’ u



-->



<p>


\begin{align*}
\E [B_t^2-t\|\mc {F}_u] &amp;=\E [(B_t-B_u)^2+2B_tB_u-B_u^2\|\mc {F}_u]-t\\ &amp;=\E [(B_t-B_u)^2\|\mc {F}_u]+2B_u\E [B_t\|\mc {F}_u]-B_u^2-t\\ &amp;=\E
[(B_t-B_u)^2]+2B_u^2-B_u^2-t\\ &amp;=(t-u)+B_u^2-t\\ &amp;=B_u^2-u
\end{align*}
as required. Here we use that \(B_t-B_u\) is independent of \(\mc {F}_u\), along with both <span class="textup">(<a href="notes_2.html#??">??</a>)</span> and Lemma <a
href="notes_2.html#??">??</a>. &#x2003;&#x2003;&#x220E;
</p>

</section>

</main>

</div>

<footer>

<p>
Copyright Nic Freeman, Sheffield University, last updated April 22, 2025
</p>

</footer>



<nav class="botnavigation"><a href="notes_2.html" class="linkhome" >
Home</a></nav>

</body>
</html>
