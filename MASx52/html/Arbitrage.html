<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="author" content="Nic Freeman" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="description" content="MAS352/452/6052 Stochastic Processes and Financial Mathematics, Sheffield University, September 22, 2022." />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<!--[if lt IE 9]>
<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
<title>MASx52 — Arbitrage</title>
<link rel="stylesheet" type="text/css" href="lwarp-sagebrush.css" />
<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
  subequations: "0",
  section: "",
  loader: {
    load: ['[tex]/tagformat', '[tex]/textmacros'],
  },
  startup: {
    ready() {
      // These would be replaced by import commands if you wanted to make
      // a proper extension.
      const Configuration = MathJax._.input.tex.Configuration.Configuration;
      const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
      const Macro = MathJax._.input.tex.Symbol.Macro;
      const TexError = MathJax._.input.tex.TexError.default;
      const ParseUtil = MathJax._.input.tex.ParseUtil.default;
      const expandable = MathJax._.util.Options.expandable;

        // Insert the replacement string into the TeX string, and check
        // that there haven't been too many maxro substitutions (prevents
        // infinite loops).
        const useArgument = (parser, text) => {
          parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
          parser.i = 0;
          if (++parser.macroCount > parser.configuration.options.maxMacros) {
            throw new TexError('MaxMacroSub1',
            'MathJax maximum macro substitution count exceeded; ' +
            'is there a recursive macro call?');
          }
        }

        // Create the command map for:
        //     \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
        new CommandMap('Lwarp-macros', {
          ifstar: 'IfstarFunction',
          ifnextchar: 'IfnextcharFunction',
          ifblank: 'IfblankFunction',
          ifstrequal: 'IfstrequalFunction',
          gsubstitute: 'GsubstituteFunction',
          seteqnumber: 'SeteqnumberFunction'
        }, {
          // This function implements an ifstar macro.
          IfstarFunction(parser, name) {
             const resultstar = parser.GetArgument(name);
             const resultnostar = parser.GetArgument(name);
             const star = parser.GetStar();                 // true if there is a *
             useArgument(parser, star ? resultstar : resultnostar);
          },

          // This function implements an ifnextchar macro.
          IfnextcharFunction(parser, name) {
            let whichchar = parser.GetArgument(name);
            if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
              // $ syntax highlighting
              whichchar = String.fromCodePoint(parseInt(whichchar));
            }
            const resultnextchar = parser.GetArgument(name);
            const resultnotnextchar = parser.GetArgument(name);
            const gotchar = (parser.GetNext() === whichchar);
            useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
          },

          // This function implements an ifblank macro.
          IfblankFunction(parser, name) {
            const blankarg = parser.GetArgument(name);
            const resultblank = parser.GetArgument(name);
            const resultnotblank = parser.GetArgument(name);
            const isblank = (blankarg.trim() == "");
            useArgument(parser, isblank ? resultblank : resultnotblank);
          },

          // This function implements an ifstrequal macro.
          IfstrequalFunction(parser, name) {
            const strequalfirst = parser.GetArgument(name);
            const strequalsecond = parser.GetArgument(name);
            const resultequal = parser.GetArgument(name);
            const resultnotequal = parser.GetArgument(name);
            const isequal = (strequalfirst == strequalsecond);
            useArgument(parser, isequal ? resultequal : resultnotequal);
          },

          // This function implements a gsub macro.
          GsubstituteFunction(parser, name) {
            const gsubfirst = parser.GetArgument(name);
            const gsubsecond = parser.GetArgument(name);
            const gsubthird = parser.GetArgument(name);
            let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
            useArgument(parser, gsubresult);
          },

          // This function modifies the equation numbers.
          SeteqnumberFunction(parser, name) {
              // Get the macro parameters
              const star = parser.GetStar();                  // true if there is a *
              const optBrackets = parser.GetBrackets(name);   // contents of optional brackets
              const newsubequations = parser.GetArgument(name); // the subequations argument
              const neweqsection = parser.GetArgument(name); // the eq section argument
              const neweqnumber = parser.GetArgument(name);   // the eq number argument
              MathJax.config.subequations=newsubequations ;   // a string with boolean meaning
              MathJax.config.section=neweqsection ;           // a string with numeric meaning
              parser.tags.counter = parser.tags.allCounter = neweqnumber ;
          }

        });

        // Create the Lwarp-macros package
        Configuration.create('Lwarp-macros', {
          handler: {macro: ['Lwarp-macros']}
        });

        MathJax.startup.defaultReady();

        // For forward references:
        MathJax.startup.input[0].preFilters.add(({math}) => {
          if (math.inputData.recompile){
              MathJax.config.subequations = math.inputData.recompile.subequations;
              MathJax.config.section = math.inputData.recompile.section;
          }
        });
        MathJax.startup.input[0].postFilters.add(({math}) => {
          if (math.inputData.recompile){
              math.inputData.recompile.subequations = MathJax.config.subequations;
              math.inputData.recompile.section = MathJax.config.section;
          }
        });

          // For \left, \right with unicode-math:
          const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
          const {Symbol} = MathJax._.input.tex.Symbol;
          const {MapHandler} = MathJax._.input.tex.MapHandler;
          const delimiter = MapHandler.getMap('delimiter');
          delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
          delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
          delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
          delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
          delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
          delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
          delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
          delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
          delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
          delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
          delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
          delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
          delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
          delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
          delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
          delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
          delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
          delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
          delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
          delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
          delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
          delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
          delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
          delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
          delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
          delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
          delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
          delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
          delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
          delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
          delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
          delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
          delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
          delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
          delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
          delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
          delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
          delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
          delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
    }     // ready
  },      // startup

  tex: {
    packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
    tags: "ams",
         tagformat: {
             number: function (n) {
                 if(MathJax.config.subequations==0)
                     return(MathJax.config.section + n);
                 else
                     return(MathJax.config.section + String.fromCharCode(96+n));
             },
         },
  }
}
</script>

<script
    id="MathJax-script"
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>


</head>
<body>



<a id="notes_1-autopage-20"></a>
<nav class="topnavigation"><a href="notes_1.html" class="linkhome" >
Home</a></nav>

<header>

<p>
last updated: September 22, 2022
</p>

</header>



<div class="bodyandsidetoc">
<div class="sidetoccontainer">



<nav class="sidetoc">



<div class="sidetoctitle">

<p>
<span class="sidetocthetitle">Stochastic Processes and Financial Mathematics<br />
(part one)</span>
</p>

<p>
Contents
</p>
</div>



<div class="sidetoccontents">

<p>
<a href="notes_1.html" class="linkhome" >
Home</a>
</p>

</div>

</nav>

</div>



<main class="bodycontainer">



<section class="textbody">

<h1>Stochastic Processes and Financial Mathematics<br />
(part one)</h1>

<!--MathJax customizations:-->



<div class="hidden">

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\DeclareMathOperator {\var }{var}\)

\(\DeclareMathOperator {\cov }{cov}\)

\(\newcommand {\nN }{n \in \mathbb {N}}\)

\(\newcommand {\Br }{{\cal B}(\R )}\)

\(\newcommand {\F }{{\cal F}}\)

\(\newcommand {\ds }{\displaystyle }\)

\(\newcommand {\st }{\stackrel {d}{=}}\)

\(\newcommand {\uc }{\stackrel {uc}{\rightarrow }}\)

\(\newcommand {\la }{\langle }\)

\(\newcommand {\ra }{\rangle }\)

\(\newcommand {\li }{\liminf _{n \rightarrow \infty }}\)

\(\newcommand {\ls }{\limsup _{n \rightarrow \infty }}\)

\(\newcommand {\limn }{\lim _{n \rightarrow \infty }}\)

\(\def \ra {\Rightarrow }\)

\(\def \to {\rightarrow }\)

\(\def \iff {\Leftrightarrow }\)

\(\def \sw {\subseteq }\)

\(\def \wt {\widetilde }\)

\(\def \mc {\mathcal }\)

\(\def \mb {\mathbb }\)

\(\def \sc {\setminus }\)

\(\def \v {\textbf }\)

\(\def \p {\partial }\)

\(\def \E {\mb {E}}\)

\(\def \P {\mb {P}}\)

\(\def \R {\mb {R}}\)

\(\def \C {\mb {C}}\)

\(\def \N {\mb {N}}\)

\(\def \Q {\mb {Q}}\)

\(\def \Z {\mb {Z}}\)

\(\def \B {\mb {B}}\)

\(\def \~{\sim }\)

\(\def \-{\,;\,}\)

\(\def \|{\,|\,}\)

\(\def \qed {$\blacksquare $}\)

\(\def \1{\unicode {x1D7D9}}\)

\(\def \cadlag {c\&grave;{a}dl\&grave;{a}g}\)

\(\def \p {\partial }\)

\(\def \l {\left }\)

\(\def \r {\right }\)

\(\def \F {\mc {F}}\)

\(\def \G {\mc {G}}\)

\(\def \H {\mc {H}}\)

\(\def \Om {\Omega }\)

\(\def \om {\omega }\)

</div>

<p>
<!--
......       section Arbitrage ......
-->
<h4 id="autosec-21"><span class="sectionnumber">1.3&#x2003;</span>Arbitrage</h4>
<a id="notes_1-autopage-21"></a>
<a id="notes_1-autofile-4"></a> <a id="sec:arbitrage"></a>

<p>
We now introduce a key concept in mathematical finance, known as <b>arbitrage</b>. We say that arbitrage occurs in a market if it possible to make money, for free, without risk of losing money.
</p>

<p>
There is a subtle distinction to be made here. We might sometimes <i>expect</i> to make money, on average. But an arbitrage possibility only occurs when it is possible to make money without any chance of
losing it.
</p>
<div class="theorembodyexample">

<ul style="list-style-type:none">



<a id="autoid-3"></a>
<li>
<p>
<span class="theoremheaderplain">Example 1.3.1</span> <a id="autoid-4" ></a ><a id="ex:simple_arbitrage"></a> Suppose that, in the one-period market, someone offered to sell us a single unit of
stock for a special price \(\frac {s}{2}\) at time \(0\). We could then:
</p>
<ul style="list-style-type:none">


<li>
<p>
1. Take out a loan of \(\frac {s}{2}\) from the bank.
</p>


</li>
<li>


<p>
2. Buy the stock, at the special price, for \(\frac {s}{2}\) cash.
</p>


</li>
<li>


<p>
3. Sell the stock, at the market rate, for \(s\) cash.
</p>


</li>
<li>


<p>
4. Repay our loan of \(\frac {s}{2}\) to the bank (we still are at \(t=0\), so no interest is due).
</p>


</li>
<li>


<p>
5. Profit!
</p>
</li>
</ul>

<p>
We now have no debts and \(\frac {s}{2}\) cash, with certainty. This is an example of arbitrage.
</p>


</li>

</ul>

</div>

<p>
Example <a href="Arbitrage.html#ex:simple_arbitrage">1.3.1</a> is obviously artificial. It does illustrates an important point: no one should sell anything at a price that makes an arbitrage possible.
However, if nothing is sold at a price that would permit arbitrage then, equally, nothing can be bought for a price that would permit arbitrage. With this in mind:
</p>
<div class="framed">

<p>
We assume that no arbitrage can occur in our market.
</p>
</div>

<p>
Let us step back and ask a natural question, about our market. Suppose we wish to have a single unit of stock delivered to us at time \(T=1\), but we want to agree in advance, at time \(0\), what price \(K\) we
will pay for it. To do so, we would enter into a <b>contract</b>. A contract is an agreement between two (or more) parties (i.e.&nbsp;people, companies, institutions, etc) that they will do something together.
</p>

<p>
Consider a contract that refers to one party as the buyer and another party as the seller. The contract specifies that:
</p>
<blockquote>

<p>
At time \(1\), the seller will be paid \(K\) cash and will deliver one unit of stock to the buyer.
</p>
</blockquote>

<p>
A contract of this form is known as a <b>forward</b> contract. Note that no money changes hands at time \(0\). The price \(K\) that is paid at time \(1\) is known as the <b>strike price</b>. The question is:
what should be the value of \(K\)?
</p>

<p>
In fact, there is <i>only one</i> possible value for \(K\). This value is
</p>

<span class="hidden"> \(\seteqnumber{0}{1.}{0}\)</span>

<!--



                                                             K = s(1 + r).                                                           (1.1)                                 --><a id="eq:forward_strike"></a><!--

-->

<p>


\begin{equation}
\label {eq:forward_strike} K=s(1+r).
\end{equation}


</p>

<p>
Let us now explain why. We argue by contradiction.
</p>
<ul style="list-style-type:none">


<li>
<p>
• Suppose that a price \(K&gt;s(1+r)\) was agreed. Then we could do the following:
</p>
<ul style="list-style-type:none">


<li>
<p>
1. At time \(0\), enter into a forward contract as the seller.
</p>


</li>
<li>


<p>
2. Borrow \(s\) from the bank, and use it buy a single unit of stock.
</p>


</li>
<li>


<p>
3. Wait until time \(1\).
</p>


</li>
<li>


<p>
4. Sell the stock (as agreed in our contract) in return for \(K\) cash.
</p>


</li>
<li>


<p>
5. We owe the bank \(s(1+r)\) to pay back our loan, so we pay this amount to the bank.
</p>


</li>
<li>


<p>
6. We are left with \(K-s(1+r)&gt;0\) profit, in cash.
</p>
</li>
</ul>
<p>
With this strategy we are <i>certain</i> to make a profit. This is arbitrage!
</p>
</li>
<li>


<p>
• Suppose, instead, that a price \(K&lt;s(1+r)\) was agreed. Then we could:
</p>
<ul style="list-style-type:none">


<li>
<p>
1. At time \(0\), enter into a forward contract as the buyer.
</p>


</li>
<li>


<p>
2. Borrow a single unit of stock from the stockbroker.
</p>


</li>
<li>


<p>
3. Sell this stock, in return for \(s\) cash.
</p>


</li>
<li>


<p>
4. Wait until time \(1\).
</p>


</li>
<li>


<p>
5. We now have \(s(1+r)\) in cash. Since \(K&lt;s(1+r)\) we can use \(K\) of this cash to buy a single unit of stock (as agreed in our contract).
</p>


</li>
<li>


<p>
6. Use the stock we just bought to pay back the stockbroker.
</p>


</li>
<li>


<p>
7. We are left with \(s(1+r)-K&gt;0\) profit, in cash.
</p>
</li>
</ul>
<p>
Once again, with this strategy we are <i>certain</i> to make a profit. Arbitrage!
</p>
</li>
</ul>

<p>
Therefore, we reach the surprising conclusion that the only possible choice is \(K=s(1+r)\). We refer to \(s(1+r)\) as the arbitrage free value for \(K\). This is our first example of an important principle:
</p>
<div class="framed">

<p>
The absence of arbitrage can force prices to take particular values. This is known as <b>arbitrage free pricing</b>.
</p>
</div>
<!--
......   subsection Expectation versus arbitrage ......
-->
<h5 id="autosec-26">Expectation versus arbitrage</h5>
<a id="notes_1-autopage-26"></a>



<p>
What of pricing by expectation? Let us, temporarily, forget about arbitrage and try to use pricing by expectation to find \(K\).
</p>

<p>
The value of our forward contract at time \(1\), from the point of view of the buyer, is \(S_1-K\). It costs nothing to enter into the forward contract, so if we believed that we should price the contract by its
expectation, we would want it to cost nothing! This would mean that \(\E [S_1-K]=0\), which means we’d choose
</p>

<span class="hidden"> \(\seteqnumber{0}{1.}{1}\)</span>

<!--



                                                          K = E[S1 ] = supu + sdpd .                                                          (1.2)                                 --><a id="eq:naive_K"></a><!--

-->

<p>


\begin{equation}
\label {eq:naive_K} K=\E [S_1]=sup_u+sdp_d.
\end{equation}


</p>

<p>
This is <i>not</i> the same as the formula \(K=s(1+r)\), which we deduced in the previous section.
</p>

<p>
It is possible that our two candidate formulas for \(K\) ‘accidentally’ agree, that is \(up_u+dp_d=s(1+r)\), but they are only equal for very specific values of \(u,p_u,d,p_d,s\) and \(r\). Observations of real
markets show that this doesn’t happen.
</p>

<p>
It may feel very surprising that <span class="textup">(<a href="Arbitrage.html#eq:naive_K">1.2</a>)</span> is different to <span class="textup">(<a
href="Arbitrage.html#eq:forward_strike">1.1</a>)</span>. The reality is, that financial markets are arbitrage free, and the <i>correct</i> strike price for our forward contract is \(K=s(1+r)\). However
intuitively appealing it might seem to price by expected value, it is not what happens in reality.
</p>

<p>
Does this mean that, with the correct strike price \(K=s(1+r)\), on average we either make or lose money by entering into a forward contract? Yes, it does. But investors are often not concerned with average
payoffs – the world changes too quickly to make use of them. Investors are concerned with what happens to them <i>personally</i>. Having realized this, we can give a short explanation, in economic terms, of why
markets are arbitrage free.
</p>

<p>
If it is possible to carry out arbitrage within a market, traders will<sup>1</sup> discover how and immediately do so. This creates high demand to buy undervalued commodities. It also creates high demand to
borrow overvalued commodities. In turn, this demand causes the price of commodities to adjust, until it is no longer possible to carry out arbitrage. The result is that the market constantly adjusts, and stays in an
equilibrium in which no arbitrage is possible.
</p>

<p>
Of course, in many respects our market is an imperfect model. We will discuss its shortcomings, as well as produce better models, as part of the course.
</p>
<div role="note" class="footnotes">

<a id="notes_1-autopage-27"></a>

<p>
<sup>1</sup>&nbsp;Usually.
</p>



</div>



<div class="theorembodyremark">

<ul style="list-style-type:none">



<a id="autoid-5"></a>
<li>
<p>
<span class="theoremheaderplain">Remark 1.3.2</span> <a id="autoid-6" ></a >We will not mention ‘pricing by expectation’ again in the course. In a liquid market, arbitrage free pricing is what matters.
</p>


</li>

</ul>

</div>

<figure id="autoid-7" class="figure ">
<div class="center">

<p>


<a href="lloyds_lse.png" target="_blank" ><img
      src="lloyds_lse.png"
      style="
      width:390pt;
      "
      class="inlineimage"
      alt="(The stock price in GBP of Lloyds Banking Group)"
></a>
</p>


<div class="figurecaption">
<p>
Figure 1.1:&nbsp;The stock price in GBP of Lloyds Banking Group, from September 2011 to September 2016.
</p>
</div>

<a id="fig:lloyds"></a>

</div>

</figure>

</section>

</main>

</div>

<footer>

<p>
Copyright Nic Freeman, Sheffield University, last updated September 22, 2022
</p>

</footer>



<nav class="botnavigation"><a href="notes_1.html" class="linkhome" >
Home</a></nav>

</body>
</html>
