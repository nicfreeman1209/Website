<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="author" content="Nic Freeman" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="description" content="MAS352/61023 Stochastic Processes and Financial Mathematics, Sheffield University, April 22, 2025." />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>MASx52 — Stochastic processes in continuous time</title>
<link rel="stylesheet" type="text/css" href="sans-serif-lwarp-sagebrush.css" />
<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
  subequations: "0",
  section: "",
  loader: {
    load: ['[tex]/tagformat', '[tex]/textmacros'],
  },
  startup: {
    ready() {
      // These would be replaced by import commands if you wanted to make
      // a proper extension.
      const Configuration = MathJax._.input.tex.Configuration.Configuration;
      const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
      const Macro = MathJax._.input.tex.Symbol.Macro;
      const TexError = MathJax._.input.tex.TexError.default;
      const ParseUtil = MathJax._.input.tex.ParseUtil.default;
      const expandable = MathJax._.util.Options.expandable;

        // Insert the replacement string into the TeX string, and check
        // that there haven't been too many maxro substitutions (prevents
        // infinite loops).
        const useArgument = (parser, text) => {
          parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
          parser.i = 0;
          if (++parser.macroCount > parser.configuration.options.maxMacros) {
            throw new TexError('MaxMacroSub1',
            'MathJax maximum macro substitution count exceeded; ' +
            'is there a recursive macro call?');
          }
        }

        // Create the command map for:
        //     \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
        new CommandMap('Lwarp-macros', {
          ifstar: 'IfstarFunction',
          ifnextchar: 'IfnextcharFunction',
          ifblank: 'IfblankFunction',
          ifstrequal: 'IfstrequalFunction',
          gsubstitute: 'GsubstituteFunction',
          seteqnumber: 'SeteqnumberFunction'
        }, {
          // This function implements an ifstar macro.
          IfstarFunction(parser, name) {
             const resultstar = parser.GetArgument(name);
             const resultnostar = parser.GetArgument(name);
             const star = parser.GetStar();                 // true if there is a *
             useArgument(parser, star ? resultstar : resultnostar);
          },

          // This function implements an ifnextchar macro.
          IfnextcharFunction(parser, name) {
            let whichchar = parser.GetArgument(name);
            if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
              // $ syntax highlighting
              whichchar = String.fromCodePoint(parseInt(whichchar));
            }
            const resultnextchar = parser.GetArgument(name);
            const resultnotnextchar = parser.GetArgument(name);
            const gotchar = (parser.GetNext() === whichchar);
            useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
          },

          // This function implements an ifblank macro.
          IfblankFunction(parser, name) {
            const blankarg = parser.GetArgument(name);
            const resultblank = parser.GetArgument(name);
            const resultnotblank = parser.GetArgument(name);
            const isblank = (blankarg.trim() == "");
            useArgument(parser, isblank ? resultblank : resultnotblank);
          },

          // This function implements an ifstrequal macro.
          IfstrequalFunction(parser, name) {
            const strequalfirst = parser.GetArgument(name);
            const strequalsecond = parser.GetArgument(name);
            const resultequal = parser.GetArgument(name);
            const resultnotequal = parser.GetArgument(name);
            const isequal = (strequalfirst == strequalsecond);
            useArgument(parser, isequal ? resultequal : resultnotequal);
          },

          // This function implements a gsub macro.
          GsubstituteFunction(parser, name) {
            const gsubfirst = parser.GetArgument(name);
            const gsubsecond = parser.GetArgument(name);
            const gsubthird = parser.GetArgument(name);
            let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
            useArgument(parser, gsubresult);
          },

          // This function modifies the equation numbers.
          SeteqnumberFunction(parser, name) {
              // Get the macro parameters
              const star = parser.GetStar();                  // true if there is a *
              const optBrackets = parser.GetBrackets(name);   // contents of optional brackets
              const newsubequations = parser.GetArgument(name); // the subequations argument
              const neweqsection = parser.GetArgument(name); // the eq section argument
              const neweqnumber = parser.GetArgument(name);   // the eq number argument
              MathJax.config.subequations=newsubequations ;   // a string with boolean meaning
              MathJax.config.section=neweqsection ;           // a string with numeric meaning
              parser.tags.counter = parser.tags.allCounter = neweqnumber ;
          }

        });

        // Create the Lwarp-macros package
        Configuration.create('Lwarp-macros', {
          handler: {macro: ['Lwarp-macros']}
        });

        MathJax.startup.defaultReady();

        // For forward references:
        MathJax.startup.input[0].preFilters.add(({math}) => {
          if (math.inputData.recompile){
              MathJax.config.subequations = math.inputData.recompile.subequations;
              MathJax.config.section = math.inputData.recompile.section;
          }
        });
        MathJax.startup.input[0].postFilters.add(({math}) => {
          if (math.inputData.recompile){
              math.inputData.recompile.subequations = MathJax.config.subequations;
              math.inputData.recompile.section = MathJax.config.section;
          }
        });

          // For \left, \right with unicode-math:
          const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
          const {Symbol} = MathJax._.input.tex.Symbol;
          const {MapHandler} = MathJax._.input.tex.MapHandler;
          const delimiter = MapHandler.getMap('delimiter');
          delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
          delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
          delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
          delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
          delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
          delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
          delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
          delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
          delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
          delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
          delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
          delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
          delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
          delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
          delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
          delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
          delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
          delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
          delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
          delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
          delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
          delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
          delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
          delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
          delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
          delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
          delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
          delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
          delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
          delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
          delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
          delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
          delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
          delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
          delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
          delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
          delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
          delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
          delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
    }     // ready
  },      // startup

  tex: {
    packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
    tags: "ams",
         tagformat: {
             number: function (n) {
                 if(MathJax.config.subequations==0)
                     return(MathJax.config.section + n);
                 else
                     return(MathJax.config.section + String.fromCharCode(96+n));
             },
         },
  }
}
</script>

<script
    id="MathJax-script"
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-J4222H8D03"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-J4222H8D03');
</script>
<!-- Google tag (gtag.js) -->


</head>
<body>



<a id="notes_2-autopage-100"></a>
<nav class="topnavigation"><a href="notes_2.html" class="linkhome" >
Home</a></nav>

<header>

<p>
last updated: April 22, 2025
</p>

</header>



<div class="bodyandsidetoc">
<div class="sidetoccontainer">



<nav class="sidetoc">



<div class="sidetoctitle">

<p>
<span class="sidetocthetitle">Stochastic Processes and Financial Mathematics<br />
(part two)</span>
</p>

<p>
Contents
</p>
</div>



<div class="sidetoccontents">

<p>
<a href="notes_2.html" class="linkhome" >
Home</a>
</p>

</div>

</nav>

</div>



<main class="bodycontainer">



<section class="textbody">

<h1>Stochastic Processes and Financial Mathematics<br />
(part two)</h1>

<!--MathJax customizations:-->
<div data-nosnippet
      style="display:none"
>

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\DeclareMathOperator {\var }{var}\)

\(\DeclareMathOperator {\cov }{cov}\)

\(\DeclareMathOperator {\indeg }{deg_{in}}\)

\(\DeclareMathOperator {\outdeg }{deg_{out}}\)

\(\newcommand {\nN }{n \in \mathbb {N}}\)

\(\newcommand {\Br }{{\cal B}(\R )}\)

\(\newcommand {\F }{{\cal F}}\)

\(\newcommand {\ds }{\displaystyle }\)

\(\newcommand {\st }{\stackrel {d}{=}}\)

\(\newcommand {\uc }{\stackrel {uc}{\rightarrow }}\)

\(\newcommand {\la }{\langle }\)

\(\newcommand {\ra }{\rangle }\)

\(\newcommand {\li }{\liminf _{n \rightarrow \infty }}\)

\(\newcommand {\ls }{\limsup _{n \rightarrow \infty }}\)

\(\newcommand {\limn }{\lim _{n \rightarrow \infty }}\)

\(\def \ra {\Rightarrow }\)

\(\def \to {\rightarrow }\)

\(\def \iff {\Leftrightarrow }\)

\(\def \sw {\subseteq }\)

\(\def \wt {\widetilde }\)

\(\def \mc {\mathcal }\)

\(\def \mb {\mathbb }\)

\(\def \sc {\setminus }\)

\(\def \v {\textbf }\)

\(\def \p {\partial }\)

\(\def \E {\mb {E}}\)

\(\def \P {\mb {P}}\)

\(\def \R {\mb {R}}\)

\(\def \C {\mb {C}}\)

\(\def \N {\mb {N}}\)

\(\def \Q {\mb {Q}}\)

\(\def \Z {\mb {Z}}\)

\(\def \B {\mb {B}}\)

\(\def \~{\sim }\)

\(\def \-{\,;\,}\)

\(\def \|{\,|\,}\)

\(\def \qed {$\blacksquare $}\)

\(\def \1{\unicode {x1D7D9}}\)

\(\def \cadlag {c\&grave;{a}dl\&grave;{a}g}\)

\(\def \p {\partial }\)

\(\def \l {\left }\)

\(\def \r {\right }\)

\(\def \F {\mc {F}}\)

\(\def \G {\mc {G}}\)

\(\def \H {\mc {H}}\)

\(\def \Om {\Omega }\)

\(\def \om {\omega }\)

\(\def \Vega {\mc {V}}\)

</div>

<!--
......     chapter Stochastic processes in continuous time ......
-->
<h3 id="autosec-101">Chapter&nbsp;<span class="sectionnumber">14&#x2003;</span>Stochastic processes in continuous time</h3>
<a id="notes_2-autopage-101"></a>
<a id="notes_2-autofile-17"></a>

<a id="c:stoch_procs_3"></a>

<p>
We’ve already made several comparisons between ordinary differential equations and SDEs. We make a further connection in this section: we show how SDEs can be used to represent solutions to a particular family
of partial differential equations. We’ll also develop a little bit of general theory concerning the Markov property.
</p>
<!--
......   section The Feynman-Kac formula ......
-->
<h4 id="autosec-102"><span class="sectionnumber">14.1&#x2003;</span>The Feynman-Kac formula</h4>
<a id="notes_2-autopage-102"></a>



<a id="s:fk"></a>

<p>
Consider \(F(t,x)\) where \(t\in [0,T]\) and \(x\in \R \). We will begin by looking at the partial differential equation
</p>
<span class="hidden"> \(\seteqnumber{0}{14.}{0}\)</span>



<!--



                                                                            ∂F                  ∂F         1        ∂2F
                                                                               (t, x) + α(t, x)                         (t, x) = 0
                                                                                                   (t, x) + β(t, x)2 2(14.1)                                  --><a id="eq:fk1a"></a><!--
                                                                            ∂t                  ∂x         2        ∂x
                                                                                                                       (T, x) = Φ(x)
                                                                                                                     F(14.2)                                  --><a id="eq:fk1b"></a><!--



-->



<p>


\begin{align}
\frac {\p F}{\p t}(t,x)+\alpha (t,x)\frac {\p F}{\p x}(t,x)+\frac {1}{2}\beta (t,x)^2\frac {\p ^2F}{\p x^2}(t,x)&amp;=0\label {eq:fk1a}\\ F(T,x)&amp;=\Phi (x)\label {eq:fk1b}
\end{align}
Here, \(\alpha (t,x)\) and \(\beta (t,x)\) are (deterministic) continuous functions, and \(\Phi (x)\) is a function known as the <i>boundary condition</i>.
</p>
<div class="theorembodyremark">

<ul class="list" style="list-style-type:none">



<a id="autoid-77"></a>
<li>
<p>
<span class="listmarker"> <span class="theoremheaderplain">Remark 14.1.1</span></span> <a id="autoid-78" ></a >\(\offsyl \) Those familiar with partial differential equations may want to hear
the ‘proper’ terminology: this is a second order parabolic PDE with a terminal boundary condition.
</p>


</li>

</ul>

</div>

<p>
We will now show that the solutions of this PDE can be written in terms the solutions to a SDE. In particular, let \(X\) be a stochastic process that satisfies
</p>

<span class="hidden"> \(\seteqnumber{0}{14.}{2}\)</span>

<!--



                                         dXu = α(u, Xu ) du + β(u, Xu ) dBu .                                        (14.3)                                                       --><a id="eq:fk_base"></a><!--

-->

<p>


\begin{equation}
\label {eq:fk_base} dX_u=\alpha (u,X_u)\,du+\beta (u,X_u)\,dB_u.
\end{equation}


</p>

<p>
We will need to consider solutions to this SDE where we vary the initial value of \(x\), and also the time at which the ‘initial’ value occurs. For given \(x\in \R \) and \(t\in [0,T]\) we write the subscripts \(\P
_{t,x}\) (and \(\E _{t,x}\)) to specify that \(X\) represents the solution of <span class="textup">(<a href="notes_2.html#??">??</a>)</span> with the initial condition that \(X_t=x\) (and we are then
interested in \(X_u\) during time \(u\in [t,T]\)). We will continue to use \(\P \) and \(\E \) to denote starting at time \(0\) with unspecified initial value \(X_0\). We assume also that \(\beta (t,X_t)\frac
{\p F}{\p x}(u,X_u)\) is in \(\mc {H}^2\), to ensure that the Ito integrals in the proof really exist.
</p>

<p>
The connection is as follows.
</p>
<div class="theorembodylemma">

<ul class="list" style="list-style-type:none">



<a id="autoid-79"></a>
<li>
<p>
<span class="listmarker"> <span class="theoremheaderplain">Lemma 14.1.2</span></span> <a id="autoid-80" ></a ><a id="l:fk_1"></a> Suppose that \(F\) is a solution of <span
class="textup">(<a href="notes_2.html#??">??</a>)</span> and <span class="textup">(<a href="notes_2.html#??">??</a>)</span>. Then,
</p>

<p>
\[F(t,x)=\E _{t,x}\l [\Phi (X_T)\r ]\]
</p>

<p>
for all \(x\in \R \) and \(t\in [0,T]\).
</p>


</li>

</ul>

</div>

<p>
<span class="textsc">Proof:</span><span style="width:5.38533pt; display:inline-block"><!----></span> We apply Ito’s formula to \(Z_t=F(t,X_t)\), giving
</p>

<p>
\[dZ_t=\l (\frac {\p F}{\p t}+\alpha (t,X_t)\frac {\p F}{\p x}+\frac 12\beta (t,X_t)^2\frac {\p ^2 F}{\p x^2}\r )\,dt + \beta (t,X_t) \frac {\p F}{\p x}\,dB_t\]
</p>

<p>
where, as usual, we have suppressed the \((t,X_t)\) arguments of the partial derivatives of \(F\). We know that \(F\) satisfies the PDE <span class="textup">(<a href="notes_2.html#??">??</a>)</span>,
which means the first term on the right hand side of the above vanishes. Writing the result out with integrals, and taking the time limits to be \([t,T]\), then gives
</p>

<p>
\[F(T,X_T)=F(t,X_t)+\int _t^T\beta (u,X_u) \frac {\p F}{\p x}(u,X_u)\,dB_u.\]
</p>

<p>
We now take expectations \(\E _{t,x}\), and recall from Theorem <a href="notes_2.html#??">??</a> that the expectation of integrals with respect to \(dB_t\) is zero. Note that here, to apply Theorem <a
href="notes_2.html#??">??</a>, we use that \(\beta (t,X_t)\frac {\p F}{\p x}(u,X_u)\) is in \(\mc {H}^2\). This leaves us with
</p>

<p>
\[\E _{t,x}[F(T,X_T)]=\E _{t,x}[F(t,X_t)]\]
</p>

<p>
Under \(\E _{t,x}\) we have \(X_t=x\), so \(F(t,X_t)=F(t,x)\), which is deterministic. From <span class="textup">(<a href="notes_2.html#??">??</a>)</span> we have \(F(T,X_T)=\Phi (T)\), which
is also deterministic. Hence we have
</p>

<p>
\[\E _{t,x}[\Phi (X_T)]=F(t,x)\]
</p>

<p>
as required. &#x2003;&#x2003;&#x220E;
</p>

<p>
Lemma <a href="notes_2.html#??">??</a>, <span class="textup">(<a href="notes_2.html#??">??</a>)</span> is very useful, from a theoretical point of view, but it is not quite what we need for later.
The PDE that will turn out to be important for option pricing is
</p>
<span class="hidden"> \(\seteqnumber{0}{14.}{3}\)</span>



<!--



                                                                          ∂F                  ∂F         1           2
                                                                                                                  2∂ F
                                                                             (t, x) + α(t, x)    (t, x) + β(t, x)(14.4) (t, x) − rF (t, x) = 0                                    --><a id="eq:fk2a"></a><!--
                                                                          ∂t                  ∂x         2          ∂x2
                                                                                                                 (14.5)          F (T, x) = Φ(x)                                  --><a id="eq:fk2b"></a><!--



-->



<p>


\begin{align}
\frac {\p F}{\p t}(t,x)+\alpha (t,x)\frac {\p F}{\p x}(t,x)+\frac {1}{2}\beta (t,x)^2\frac {\p ^2F}{\p x^2}(t,x)-rF(t,x)&amp;=0\label {eq:fk2a}\\ F(T,x)&amp;=\Phi (x)\label
{eq:fk2b}
\end{align}
where \(\alpha ,\beta , \Phi \) are as before and \(r\) is a deterministic constant. We can treat this PDE in a similar style, even using the same SDE for \(X\); we just need an extra term in the calculations.
</p>
<div class="theorembodylemma">

<ul class="list" style="list-style-type:none">



<a id="autoid-81"></a>
<li>
<p>
<span class="listmarker"> <span class="theoremheaderplain">Lemma 14.1.3</span></span> <a id="autoid-82" ></a ><a id="l:fk_2"></a> Suppose that \(F\) is a solution of <span
class="textup">(<a href="notes_2.html#??">??</a>)</span> and <span class="textup">(<a href="notes_2.html#??">??</a>)</span>. Then,
</p>

<span class="hidden"> \(\seteqnumber{0}{14.}{5}\)</span>

<!--



                                     F (t, x) = e−r(T −t) Et,x [Φ(XT )]                                           (14.6)                                                   --><a id="eq:fk_2_eq"></a><!--

-->

<p>


\begin{equation}
\label {eq:fk_2_eq} F(t,x)=e^{-r(T-t)}\E _{t,x}\l [\Phi (X_T)\r ]
\end{equation}


</p>

<p>
for all \(x\in \R \) and \(t\in [0,T]\).
</p>


</li>

</ul>

</div>

<p>
<span class="textsc">Proof:</span><span style="width:5.38533pt; display:inline-block"><!----></span> This time we apply Ito’s formula to the process \(Z_t=e^{-rt}F(t,X_t)\). We obtain
</p>
<span class="hidden"> \(\seteqnumber{0}{14.}{6}\)</span>



<!--



                                                                                                                 1
                                                                                                                                         !
                                                                                     −rt ∂F              −rt ∂F                  ∂2F                              ∂F
                                                              dZt = −re     −rt
                                                                                  F +e        + α(t, Xt )e      + β(t, Xt )2 e−rt 2          dt + β(t, Xt )e−rt      dBt
                                                                                         ∂t                  ∂x  2               ∂x                               ∂x
                                                                                                     1
                                                                                                                           !
                                                                                  ∂F             ∂F             ∂2F                                  ∂F
                                                                  =e  −rt
                                                                            −rF +    + α(t, Xt )    + β(t, Xt )2 2             dt + e−rt β(t, Xt )      dBt .
                                                                                  ∂t             ∂x  2          ∂x                                   ∂x



-->



<p>


\begin{align*}
dZ_t &amp;=\l (-re^{-rt}F+e^{-rt}\frac {\p F}{\p t}+\alpha (t,X_t)e^{-rt}\frac {\p F}{\p x}+\frac 12\beta (t,X_t)^2e^{-rt}\frac {\p ^2 F}{\p x^2}\r )\,dt+\beta
(t,X_t)e^{-rt}\frac {\p F}{\p x}\,dB_t\\ &amp;=e^{-rt}\l (-rF+\frac {\p F}{\p t}+\alpha (t,X_t)\frac {\p F}{\p x}+\frac 12\beta (t,X_t)^2\frac {\p ^2 F}{\p x^2}\r
)\,dt+e^{-rt}\beta (t,X_t)\frac {\p F}{\p x}\,dB_t.
\end{align*}
We know that \(F\) satisfies <span class="textup">(<a href="notes_2.html#??">??</a>)</span>, so the first term on the right hand side vanishes. Writing the result as integrals with time interval \([t,T]\)
we obtain
</p>

<p>
\[e^{-rT}F(T,X_T)=e^{-rt}F(t,X_t)+\int _t^T e^{-ru}\beta (u,X_u)\frac {\p F}{\p x}(u,X_u)\,dB_u.\]
</p>

<p>
The second term on the right is an Ito integral, and hence has mean zero. Taking expectations \(\E _{t,x}\) leaves us with
</p>

<p>
\[\E _{t,x}\l [e^{-rT}F(T,X_T)\r ]=\E _{t,x}\l [e^{-rt}F(t,X_t)\r ].\]
</p>

<p>
Under \(\E _{t,x}\) we have \(X_t=x\), so \(F(t,X_t)=F(t,x)\) which is deterministic. We obtain that
</p>

<p>
\[e^{-r(T-t)}\E _{t,x}\l [F(T,X_T)\r ]=F(t,x)\]
</p>

<p>
and using <span class="textup">(<a href="notes_2.html#??">??</a>)</span> then gives us
</p>

<p>
\[e^{-r(T-t)}\E _{t,x}\l [\Phi (X_T)\r ]=F(t,x)\]
</p>

<p>
as required. &#x2003;&#x2003;&#x220E;
</p>
<div class="theorembodyremark">

<ul class="list" style="list-style-type:none">



<a id="autoid-83"></a>
<li>
<p>
<span class="listmarker"> <span class="theoremheaderplain">Remark 14.1.4</span></span> <a id="autoid-84" ></a >Setting \(r=0\) in Lemma <a href="notes_2.html#??">??</a> gets us back to
the statement of Lemma <a href="notes_2.html#??">??</a>.
</p>


</li>

</ul>

</div>

<p>
We can start to see the connection to finance emerging in <span class="textup">(<a href="notes_2.html#??">??</a>)</span>. If we set \(t=0\), we obtain
</p>

<p>
\[F(0,x)=e^{-rT}\E _{0,x}[\Phi (X_T)]\]
</p>

<p>
which bears a resemblance to the risk-neutral valuation formula we found in Chapter <a href="The-binomial-model.html#c:bin_model">5</a>. The connection will be explored when we come to apply Lemma
<a href="notes_2.html#??">??</a>, in Section <a href="notes_2.html#??">??</a>.
</p>

<p>
Both Lemma <a href="notes_2.html#??">??</a> and <a href="notes_2.html#??">??</a> assert that, for some particular PDE, if a solution exists then it has a particular form. They assert uniqueness of
solutions, without proving that a solution exists. In fact, in both cases, provided that \(\alpha \) and \(\beta \) are nice enough functions then a (unique) solution does exist; this can be proved either using
theory from the PDE world, or by using delicate real analysis to show explicitly that \(\E _{t,x}[\Phi (X_T)]\) is differentiable. We don’t include this step in our course.
</p>

<p>
Lemmas <a href="notes_2.html#??">??</a>, <a href="notes_2.html#??">??</a> and variations on the same theme are collectively known as ‘the’ <i>Feynman-Kac formula</i>. They are named after the
Richard Feynman (a theoretical physicist, famous for his work in quantum mechanics) and Mark Kac (pronounced “Kats”, a mathematician famous for his contributions to probability theory).
</p>
<div class="theorembodyremark">

<ul class="list" style="list-style-type:none">



<a id="autoid-85"></a>
<li>
<p>
<span class="listmarker"> <span class="theoremheaderplain">Remark 14.1.5</span></span> <a id="autoid-86" ></a >\(\offsyl \) There are many other families of PDEs that have relationships to
other families of stochastic processes. These connections are exploited by researchers to transfer information and results between the ‘dual’ worlds of stochastic processes and PDEs.
</p>


</li>

</ul>

</div>
<div class="theorembodyexample">

<ul class="list" style="list-style-type:none">



<a id="autoid-87"></a>
<li>
<p>
<span class="listmarker"> <span class="theoremheaderplain">Example 14.1.6</span></span> <a id="autoid-88" ></a >In cases where we can solve <span class="textup">(<a
href="notes_2.html#??">??</a>)</span>, we can use the Feynman-Kac formula to find explicit solutions to PDEs. For example, consider
</p>
<span class="hidden"> \(\seteqnumber{0}{14.}{6}\)</span>



<!--



                                                                                     ∂F         1 ∂2F
                                                                                        (t, x) + σ 2 2 (t, x) = 0
                                                                                     ∂t         2 ∂x
                                                                                                          f (T, x) = x2 .



-->



<p>


\begin{align*}
\frac {\p F}{\p t}(t,x)+\frac 12\sigma ^2\frac {\p ^2 F}{\p x^2}(t,x)&amp;=0\\ f(T,x)&amp;=x^2.
\end{align*}
Here, \(\sigma \geq 0\) is a deterministic constant and \(t,x\in \R \).
</p>

<p>
We have \(\alpha (t,x)=0\), \(\beta (t,x)=\sigma \) (both constants), and \(\Phi (x)=x^2\). From Lemma <a href="notes_2.html#??">??</a> the solution is given by
</p>

<p>
\[F(t,x)=\E _{t,x}[X_T^2]\]
</p>

<p>
where \(dX_u=0\,du+\sigma \,dB_u=\sigma \,dB_u\). This means that
</p>
<span class="hidden"> \(\seteqnumber{0}{14.}{6}\)</span>



<!--


                                                                                               Z T
                                                                               XT = Xt + σ           dBu = Xt + σ(BT − Bt ).
                                                                                                t




-->



<p>


\begin{align*}
X_T&amp;=X_t+\sigma \int _t^T\,dB_u =X_t+\sigma (B_T-B_t).
\end{align*}
Therefore,
</p>
<span class="hidden"> \(\seteqnumber{0}{14.}{6}\)</span>



<!--


                                                                                           h                      i
                                                                            F (t, x) = Et,x (Xt + σ(BT − Bt ))2
                                                                                       h                      i
                                                                                   = E (x + σ(BT − Bt ))2
                                                                                       h                                       i
                                                                                   = E x2 + σ 2 (BT − Bt )2 + 2xσ(BT − Bt )

                                                                                   = x2 + σ 2 (T − t).



-->



<p>


\begin{align*}
F(t,x)&amp;=\E _{t,x}\l [\l (X_t+\sigma (B_T-B_t)\r )^2\r ]\\ &amp;=\E \l [\l (x+\sigma (B_T-B_t)\r )^2\r ]\\ &amp;=\E \l [x^2+\sigma ^2(B_T-B_t)^2+2x\sigma (B_T-B_t)\r ]\\
&amp;=x^2+\sigma ^2(T-t).
\end{align*}
Here, we use that \(X_t=x\) under \(\E _{t,x}\) and that \(B_T-B_t\sim B_{T-t}\sim N(0,T-t)\).
</p>

<p>
See exercises <a href="notes_2.html#??">??</a> and <a href="notes_2.html#??">??</a> for further examples of this method.
</p>


</li>

</ul>

</div>

</section>

</main>

</div>

<footer>

<p>
Copyright Nic Freeman, Sheffield University, last updated April 22, 2025
</p>

</footer>



<nav class="botnavigation"><a href="notes_2.html" class="linkhome" >
Home</a></nav>

</body>
</html>
